{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyChamber \u00b6 PyChamber is an open-source application written with Qt to take anechoic chamber measurements. All measurements are saved as scikit-rf objects (or classes derived from them) which greatly simplifies post-processing. Table of Contents \u00b6 Overview : This page Installation : Ways to install PyChamber The Interface : Explains the GUI Taking a Measurement : The process of setting up and taking a measurement Calibration : How to perform a calibration Interacting with Data in Python : How to load data into Python and use it API Reference : Documentation of the Python API Contributing : How to help with the development of PyChamber Changelog : Summaries of each update of PyChamber","title":"Overview"},{"location":"#pychamber","text":"PyChamber is an open-source application written with Qt to take anechoic chamber measurements. All measurements are saved as scikit-rf objects (or classes derived from them) which greatly simplifies post-processing.","title":"PyChamber"},{"location":"#table-of-contents","text":"Overview : This page Installation : Ways to install PyChamber The Interface : Explains the GUI Taking a Measurement : The process of setting up and taking a measurement Calibration : How to perform a calibration Interacting with Data in Python : How to load data into Python and use it API Reference : Documentation of the Python API Contributing : How to help with the development of PyChamber Changelog : Summaries of each update of PyChamber","title":"Table of Contents"},{"location":"SUMMARY/","text":"Overview Installation The Interface Taking a Measurement Calibration Interacting with Data in Python Code Reference Contributing Changelog","title":"SUMMARY"},{"location":"calibration/","text":"Calibration is the process by which we characterize the gains and losses of our setup such that we can get realized gain from our measurements. This is done in PyChamber by measuring an antenna with known characteristics. PyChamber helps you through this process with the Calibration Wizard, accessible by clicking the corresponding button in the Calibration plugin. Info The wizard is only available if you are connected to an analyzer! The wizard should explain each step, but we'll go into extra detail of certian pages here if you have questions. Notes \u00b6 This is where you can notes on your calibration. The more detailed your notes, the more repeatable your experiments! These notes will be saved as part of the calibration. Reference \u00b6 This is where you upload a file containing known gain values of your reference antenna. This should be a .csv file with no headers in the format: Frequency [GHz], Gain [dB] Frequency [GHz], Gain [dB] Frequency [GHz], Gain [dB] ... If you don't have such a file, you can generate one from a manufacturer's datasheet using something like this online tool . Once it's loaded, the data should be plotted for you to verify. If everything looks okay, click next. Measure \u00b6 This is where you do the actual calibration. You first apply a label to each polarization (if you're using both) and assign the measurement parameter. You will measure each polarization individually and the loss will be plotted. You can see in the image that the loss is very large and noisy at higher frequencies in this case. You must ensure your reference antenna is above the noise floor or measurement results will be nonsense. Then you can save it to a file (again, this will be a pickled binary file). You can view a calibration any time by loading it, then clicking \"View Calibration\" in the Calibration plugin.","title":"Calibration"},{"location":"calibration/#notes","text":"This is where you can notes on your calibration. The more detailed your notes, the more repeatable your experiments! These notes will be saved as part of the calibration.","title":"Notes"},{"location":"calibration/#reference","text":"This is where you upload a file containing known gain values of your reference antenna. This should be a .csv file with no headers in the format: Frequency [GHz], Gain [dB] Frequency [GHz], Gain [dB] Frequency [GHz], Gain [dB] ... If you don't have such a file, you can generate one from a manufacturer's datasheet using something like this online tool . Once it's loaded, the data should be plotted for you to verify. If everything looks okay, click next.","title":"Reference"},{"location":"calibration/#measure","text":"This is where you do the actual calibration. You first apply a label to each polarization (if you're using both) and assign the measurement parameter. You will measure each polarization individually and the loss will be plotted. You can see in the image that the loss is very large and noisy at higher frequencies in this case. You must ensure your reference antenna is above the noise floor or measurement results will be nonsense. Then you can save it to a file (again, this will be a pickled binary file). You can view a calibration any time by loading it, then clicking \"View Calibration\" in the Calibration plugin.","title":"Measure"},{"location":"changelog/","text":"Changelog \u00b6 0.1.0 (2022-04-10) \u00b6 First release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#010-2022-04-10","text":"First release.","title":"0.1.0 (2022-04-10)"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/hrg-lab/pychamber/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 PyChamber could always use more documentation, whether as part of the official PyChamber docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/hrg-lab/pychamber/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: poetry run bump2version patch # possible: major / minor / patch git push git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/hrg-lab/pychamber/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"PyChamber could always use more documentation, whether as part of the official PyChamber docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/hrg-lab/pychamber/issues . If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: poetry run bump2version patch # possible: major / minor / patch git push git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 I'm actively working on creating excutables for download! From source \u00b6 The source for PyChamber can be downloaded from the Github repo . You can either clone the public repository: git clone git://github.com/hrg-lab/pychamber Or download the tarball: curl -OJL https://github.com/hrg-lab/pychamber/tarball/master Once you have a copy of the source, you can install it using poetry : poetry install","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"I'm actively working on creating excutables for download!","title":"Stable release"},{"location":"installation/#from-source","text":"The source for PyChamber can be downloaded from the Github repo . You can either clone the public repository: git clone git://github.com/hrg-lab/pychamber Or download the tarball: curl -OJL https://github.com/hrg-lab/pychamber/tarball/master Once you have a copy of the source, you can install it using poetry : poetry install","title":"From source"},{"location":"interact_with_data/","text":"Interacting with Data in Python \u00b6 PyChamber is deeply integrated with scikit-rf. Information about scikit-rf objects should be found in their documentation Loading Measurements \u00b6 Loading measurements is as simple as importing pychamber and calling load . import pychamber data = pychamber . load ( \"path/to/data\" ) Measurement Results \u00b6 Measurements are all saved to a single NetworkSet in the Experiment plugin's NetworkModel. Each piece of data contains metadata indicating its: Polarization name Azimuth Elevation Thankfully, scikit-rf's NetworkSet contains some helpful functions for filtering data. import pychamber measurement = pychamber . load ( \"C:/Path/To/Measurement/Data\" ) # Get all the data for the polarizations named \"Vertical\" and \"Horizontal\" vertical = measurement . sel ({ 'polarization' : 'Vertical' }) horizontal = measurement . sel ({ 'polarization' : 'Horizontal' }) # Get the elevation=0 cut-plane for the Vertical polarization el_0_cut = measurement . sel ({ 'polarization' : 'Vertical' , 'elevation' : 0 }) Getting data for a range of frequencies is a bit different and it's easiest to use a list comprehension and create a new NetworkSet. For example: # Assuming measurement is a NetworkSet with data from 18GHz-40GHz, # this would be a way to get data for 18GHz - 20GHz subset = skrf . NetworkSet ([ ntwk [ \"18GHz-20GHz\" ] for ntwk in measurement ])","title":"Interacting with Data in Python"},{"location":"interact_with_data/#interacting-with-data-in-python","text":"PyChamber is deeply integrated with scikit-rf. Information about scikit-rf objects should be found in their documentation","title":"Interacting with Data in Python"},{"location":"interact_with_data/#loading-measurements","text":"Loading measurements is as simple as importing pychamber and calling load . import pychamber data = pychamber . load ( \"path/to/data\" )","title":"Loading Measurements"},{"location":"interact_with_data/#measurement-results","text":"Measurements are all saved to a single NetworkSet in the Experiment plugin's NetworkModel. Each piece of data contains metadata indicating its: Polarization name Azimuth Elevation Thankfully, scikit-rf's NetworkSet contains some helpful functions for filtering data. import pychamber measurement = pychamber . load ( \"C:/Path/To/Measurement/Data\" ) # Get all the data for the polarizations named \"Vertical\" and \"Horizontal\" vertical = measurement . sel ({ 'polarization' : 'Vertical' }) horizontal = measurement . sel ({ 'polarization' : 'Horizontal' }) # Get the elevation=0 cut-plane for the Vertical polarization el_0_cut = measurement . sel ({ 'polarization' : 'Vertical' , 'elevation' : 0 }) Getting data for a range of frequencies is a bit different and it's easiest to use a list comprehension and create a new NetworkSet. For example: # Assuming measurement is a NetworkSet with data from 18GHz-40GHz, # this would be a way to get data for 18GHz - 20GHz subset = skrf . NetworkSet ([ ntwk [ \"18GHz-20GHz\" ] for ntwk in measurement ])","title":"Measurement Results"},{"location":"taking_a_measurement/","text":"This page will walk you through the basic steps of taking a measurement. First we'll walk through the controls in the plugin panel, then look at starting the experiment and observing the progress with the plots. The Analyzer \u00b6 First, you must connect to an analyzer and set it to take the measurements you want. Start by choosing a model from the dropdown, then an address, and then click connect. If the connection was successful, the frequency boxes will be populated with the current settings of the analyzer. Don't see your analyzer listed? Internally, PyChamber uses scikit-rf's virtual instrument module to interfacea with a network analyzer. If your analyzer is not listed, consider contributing to scikit-rf! Right now, PyChamber supports simultaneous dual polarization measurements. In the future, it might support additional simultaneous polarizations, but for now we just have the two. You can specify a name or label for each of your two polarizations in the text boxes, then the associated measurement parameter in the dropdown. The dropdown should be populated with all measurement parameters possible with your analyzer. If you only want to take one polarization, set the second to \"OFF\". The frequency box allows you to change the frequency settings of your analzyer and this may be expanded later to allow changing other settings like IF bandwidth, but for now those other settings must be changed on the analyzer. You can enter frequencies as a string such as \"10 MHz\" or as a number like 10000000. The text edit will only allow those two options. The setting on the analyzer is only changed when you press \"Enter\" or the text box loses focus. Calibration \u00b6 The process of calibration is covered in detail in Calibration . For now, just now you can load a calibration file with the \"Browse\" button, launch the calibration wizard, and view the currently loaded calibration. The Positioner \u00b6 Now you can select your positioner model and the serial port it's connected to. Currently only positioners that communicate over serial are supported. Once you've set the positioner model and port, click connect. If the connection is successful, the rest of the plugin will become active. Don't see your positioner model? PyChamber is in its early stages of development! Please consider contributing by adding support for your specific positioner :D When you first set up for your measurements, you should take care to use the jog button to align your DUT and define it's origin point. A laser is helpful!","title":"Taking a Measurement"},{"location":"taking_a_measurement/#the-analyzer","text":"First, you must connect to an analyzer and set it to take the measurements you want. Start by choosing a model from the dropdown, then an address, and then click connect. If the connection was successful, the frequency boxes will be populated with the current settings of the analyzer. Don't see your analyzer listed? Internally, PyChamber uses scikit-rf's virtual instrument module to interfacea with a network analyzer. If your analyzer is not listed, consider contributing to scikit-rf! Right now, PyChamber supports simultaneous dual polarization measurements. In the future, it might support additional simultaneous polarizations, but for now we just have the two. You can specify a name or label for each of your two polarizations in the text boxes, then the associated measurement parameter in the dropdown. The dropdown should be populated with all measurement parameters possible with your analyzer. If you only want to take one polarization, set the second to \"OFF\". The frequency box allows you to change the frequency settings of your analzyer and this may be expanded later to allow changing other settings like IF bandwidth, but for now those other settings must be changed on the analyzer. You can enter frequencies as a string such as \"10 MHz\" or as a number like 10000000. The text edit will only allow those two options. The setting on the analyzer is only changed when you press \"Enter\" or the text box loses focus.","title":"The Analyzer"},{"location":"taking_a_measurement/#calibration","text":"The process of calibration is covered in detail in Calibration . For now, just now you can load a calibration file with the \"Browse\" button, launch the calibration wizard, and view the currently loaded calibration.","title":"Calibration"},{"location":"taking_a_measurement/#the-positioner","text":"Now you can select your positioner model and the serial port it's connected to. Currently only positioners that communicate over serial are supported. Once you've set the positioner model and port, click connect. If the connection is successful, the rest of the plugin will become active. Don't see your positioner model? PyChamber is in its early stages of development! Please consider contributing by adding support for your specific positioner :D When you first set up for your measurements, you should take care to use the jog button to align your DUT and define it's origin point. A laser is helpful!","title":"The Positioner"},{"location":"the_interface/","text":"PyChamber consists of two areas: the plugin panel (in cyan), and the main area (in fuschia). The plugin panel is where most of the experiment setup is done. Additionally, user-installed plugins can be added to this panel to provide additional functionality. By default, PyChamber has the following plugins loaded to the plugin panel: Analyzer Calibration Positioner Plugins will become enabled/disabled through use. For example, the analyzer functions will only be available once you've connected to an analyzer. At the bottom is a status bar which can show some helpful status messages. Start the Measurement \u00b6 Once everything is in place, you can start your measurement. This will disable the analyzer and positioner plugins to prevent any issues trying to simultaneously control something while the experiment is taking data. The time remaining estimate will start off with a very innacurate estimate, but each time data is captured the average time at each position is updated and you should get a fairly accurate estimate pretty quickly. If you're running a full scan (azimuth and elevation), a cut-progress bar will appear showing the progress of the current cut plane. Clicking abort will stop all measurements and halt the positioner. Monitoring Progress \u00b6 Any plots will be updated live as data is taken. Feel free to change the plot settings while the measurement is being taken. Eventually, the plan is to add more supported plots (including 3D!). You can either set the scale manually or have the plot autoscale as measurements are taken, by checking the box. Saving data \u00b6 Once you're done with your measurement, you can save it to disk using the file menu. This is even true if you have to abort mid-measurement. You will be able to save what you've got. Data is saved in a binary format by pickling to reduce size. You can load it later in a python script or in PyChamber. More information on using data in a script can be found in Interacting with Data in Python","title":"The Interface"},{"location":"the_interface/#start-the-measurement","text":"Once everything is in place, you can start your measurement. This will disable the analyzer and positioner plugins to prevent any issues trying to simultaneously control something while the experiment is taking data. The time remaining estimate will start off with a very innacurate estimate, but each time data is captured the average time at each position is updated and you should get a fairly accurate estimate pretty quickly. If you're running a full scan (azimuth and elevation), a cut-progress bar will appear showing the progress of the current cut plane. Clicking abort will stop all measurements and halt the positioner.","title":"Start the Measurement"},{"location":"the_interface/#monitoring-progress","text":"Any plots will be updated live as data is taken. Feel free to change the plot settings while the measurement is being taken. Eventually, the plan is to add more supported plots (including 3D!). You can either set the scale manually or have the plot autoscale as measurements are taken, by checking the box.","title":"Monitoring Progress"},{"location":"the_interface/#saving-data","text":"Once you're done with your measurement, you can save it to disk using the file menu. This is even true if you have to abort mid-measurement. You will be able to save what you've got. Data is saved in a binary format by pickling to reduce size. You can load it later in a python script or in PyChamber. More information on using data in a script can be found in Interacting with Data in Python","title":"Saving data"},{"location":"reference/","text":"This is the reference of the PyChamber code base. Use the navigation on the left to look at specific modules","title":"Code Reference"},{"location":"reference/logger/","text":"Define a global logger with configuration.","title":"Logger"},{"location":"reference/main_window/","text":"The main PyChamber application window. MainWindow \u00b6 Bases: QMainWindow PyChamber. This is the main window of PyChamber. It is responsible for handling user interactions, managing plugins, and providing a menu and status bar. Source code in pychamber/main_window.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class MainWindow ( QMainWindow ): \"\"\"PyChamber. This is the main window of PyChamber. It is responsible for handling user interactions, managing plugins, and providing a menu and status bar. \"\"\" REQUIRED_PLUGINS = [ plugins . AnalyzerPlugin , plugins . CalibrationPlugin , plugins . ExperimentPlugin , plugins . PositionerPlugin , plugins . PlotsPlugin , ] \"\"\"list(PyChamberPlugin): List of minimum plugins required to run PyChamber\"\"\" def __init__ ( self , * args ) -> None : \"\"\"Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. \"\"\" super () . __init__ ( * args ) LOG . debug ( \"Constructing MainWindow...\" ) self . setWindowTitle ( \"PyChamber\" ) self . setWindowIcon ( QIcon ( \":/logo.png\" )) self . main_widget = QWidget ( self ) self . setCentralWidget ( self . main_widget ) self . main_layout = QHBoxLayout ( self . main_widget ) self . registered_plugins : Dict [ str , PyChamberPlugin ] = {} def _on_save_triggered ( self ) -> None : LOG . debug ( \"Launching save dialog...\" ) experiment = cast ( plugins . ExperimentPlugin , self . get_plugin ( \"experiment\" )) ntwk_model = experiment . ntwk_model if len ( ntwk_model ) == 0 : QMessageBox . warning ( self , \"No data\" , \"No data to save. Run an experiment first.\" ) return to_save = ntwk_model . data () save_name , _ = QFileDialog . getSaveFileName () if save_name != \"\" : with open ( save_name , 'wb' ) as save_file : pickle . dump ( to_save , save_file ) def _on_load_triggered ( self ) -> None : # TODO: Handle NetworkModel.data_loaded LOG . debug ( \"Launching load dialog...\" ) experiment = cast ( plugins . ExperimentPlugin , self . get_plugin ( \"experiment\" )) ntwk_model = experiment . ntwk_model file_name , _ = QFileDialog . getOpenFileName () if file_name != \"\" : try : LOG . debug ( f \"Loading { file_name } \" ) with open ( file_name , 'rb' ) as ff : data = pickle . load ( ff ) ntwk_model . load_data ( data ) except Exception : QMessageBox . critical ( self , \"Invalid File\" , \"The specified file is invalid\" ) return def _on_settings_triggered ( self ) -> None : LOG . debug ( \"Launching settings dialog...\" ) SettingsDialog . display () def _on_python_interpreter_triggered ( self ) -> None : LOG . debug ( \"Launching Python interpreter...\" ) def setup ( self ) -> None : \"\"\"Setup the window's menu and widgets.\"\"\" self . _setup_menu () self . _add_widgets () def post_visible_setup ( self ) -> None : \"\"\"Initialize registered plugins.\"\"\" LOG . debug ( \"Running post-visible setups\" ) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _post_visible_setup () self . statusBar () . showMessage ( \"Welcome to PyChamber!\" , 2000 ) def center ( self ) -> None : \"\"\"Center the window.\"\"\" qr = self . frameGeometry () cp = QDesktopWidget () . availableGeometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ()) def closeEvent ( self , event : QCloseEvent ) -> None : \"\"\"Warn the user on close. Arguments: event: the event that triggered the close. \"\"\" LOG . debug ( \"Close event triggered\" ) warning = QMessageBox () warning . setStandardButtons ( QMessageBox . Yes | QMessageBox . Cancel ) warning . setDefaultButton ( QMessageBox . Cancel ) warning . setText ( \"Are you sure you want to quit? \\n (Any unsaved data will be LOST)\" ) resp = warning . exec_ () if resp == QMessageBox . Yes : LOG . debug ( \"Close event accepted\" ) del self . settings # Saves settings super () . closeEvent ( event ) else : LOG . debug ( \"Close event canceled\" ) event . ignore () def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Arguments: plugin: plugin to register \"\"\" assert plugin . NAME is not None if plugin . NAME in self . registered_plugins : raise PyChamberPluginError ( f \"A plugin is already registered with { plugin . NAME } \" ) plugin . _register () self . registered_plugins [ plugin . NAME ] = plugin if isinstance ( plugin , PyChamberPanelPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to panel\" ) self . panel_layout . addWidget ( plugin ) elif isinstance ( plugin , PyChamberPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to right side\" ) self . right_side_layout . addWidget ( plugin ) def unregister_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Remove a plugin from PyChamber (NOT IMPLEMENTED). Arguments: plugin: plugin to remove \"\"\" raise NotImplementedError def get_plugin ( self , plugin_name : str ) -> PyChamberPlugin : \"\"\"Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Arguments: plugin_name: name of the plugin. This is defined by each plugin. \"\"\" return self . registered_plugins [ plugin_name ] def _setup_menu ( self ) -> None : LOG . debug ( \"Setting up menu...\" ) self . menu = self . menuBar () self . file = self . menu . addMenu ( \"File\" ) self . save = self . file . addAction ( \"Save\" ) self . load = self . file . addAction ( \"Load\" ) self . file . addSeparator () self . settings = self . file . addAction ( \"Settings\" ) self . file . addSeparator () self . quit = self . file . addAction ( \"Quit\" ) self . save . triggered . connect ( self . _on_save_triggered ) self . load . triggered . connect ( self . _on_load_triggered ) self . settings . triggered . connect ( self . _on_settings_triggered ) self . quit . triggered . connect ( self . close ) self . tools = self . menu . addMenu ( \"Tools\" ) self . python_interpreter = self . tools . addAction ( \"Python Terminal\" ) self . python_interpreter . triggered . connect ( self . _on_python_interpreter_triggered ) self . help = self . menu . addMenu ( \"Help\" ) self . bug = self . help . addAction ( \"Submit a Bug\" ) self . help . addSeparator () self . about = self . help . addAction ( \"About\" ) self . log = self . help . addAction ( \"View Log\" ) bug_report_url = \"https://github.com/HRG-Lab/PyChamber/issues/new\" self . bug . triggered . connect ( lambda : webbrowser . open ( bug_report_url )) self . about . triggered . connect ( AboutPyChamberDialog . display ) self . log . triggered . connect ( LogViewer . display ) def _add_widgets ( self ) -> None : LOG . debug ( \"Setting up widgets...\" ) self . panel_scroll_area = QScrollArea ( widgetResizable = True ) self . panel_widget = QWidget () self . panel_scroll_area . setWidget ( self . panel_widget ) self . panel_layout = QVBoxLayout ( self . panel_widget ) self . panel_scroll_area . setVerticalScrollBarPolicy ( Qt . ScrollBarAlwaysOn ) self . panel_scroll_area . setHorizontalScrollBarPolicy ( Qt . ScrollBarAlwaysOff ) self . right_side_layout = QVBoxLayout () self . main_layout . addWidget ( self . panel_scroll_area ) self . main_layout . addLayout ( self . right_side_layout ) for plugin in self . REQUIRED_PLUGINS : self . register_plugin ( cast ( PyChamberPlugin , plugin ( self ))) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _setup () self . panel_layout . addStretch () self . panel_scroll_area . setFixedWidth ( self . panel_widget . minimumSizeHint () . width () + self . panel_scroll_area . verticalScrollBar () . sizeHint () . width () ) REQUIRED_PLUGINS = [ plugins . AnalyzerPlugin , plugins . CalibrationPlugin , plugins . ExperimentPlugin , plugins . PositionerPlugin , plugins . PlotsPlugin ] class-attribute \u00b6 list(PyChamberPlugin): List of minimum plugins required to run PyChamber __init__ ( * args ) \u00b6 Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. Source code in pychamber/main_window.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , * args ) -> None : \"\"\"Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. \"\"\" super () . __init__ ( * args ) LOG . debug ( \"Constructing MainWindow...\" ) self . setWindowTitle ( \"PyChamber\" ) self . setWindowIcon ( QIcon ( \":/logo.png\" )) self . main_widget = QWidget ( self ) self . setCentralWidget ( self . main_widget ) self . main_layout = QHBoxLayout ( self . main_widget ) self . registered_plugins : Dict [ str , PyChamberPlugin ] = {} center () \u00b6 Center the window. Source code in pychamber/main_window.py 118 119 120 121 122 123 def center ( self ) -> None : \"\"\"Center the window.\"\"\" qr = self . frameGeometry () cp = QDesktopWidget () . availableGeometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ()) closeEvent ( event ) \u00b6 Warn the user on close. Parameters: Name Type Description Default event QCloseEvent the event that triggered the close. required Source code in pychamber/main_window.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def closeEvent ( self , event : QCloseEvent ) -> None : \"\"\"Warn the user on close. Arguments: event: the event that triggered the close. \"\"\" LOG . debug ( \"Close event triggered\" ) warning = QMessageBox () warning . setStandardButtons ( QMessageBox . Yes | QMessageBox . Cancel ) warning . setDefaultButton ( QMessageBox . Cancel ) warning . setText ( \"Are you sure you want to quit? \\n (Any unsaved data will be LOST)\" ) resp = warning . exec_ () if resp == QMessageBox . Yes : LOG . debug ( \"Close event accepted\" ) del self . settings # Saves settings super () . closeEvent ( event ) else : LOG . debug ( \"Close event canceled\" ) event . ignore () get_plugin ( plugin_name ) \u00b6 Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Parameters: Name Type Description Default plugin_name str name of the plugin. This is defined by each plugin. required Source code in pychamber/main_window.py 182 183 184 185 186 187 188 189 190 191 192 def get_plugin ( self , plugin_name : str ) -> PyChamberPlugin : \"\"\"Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Arguments: plugin_name: name of the plugin. This is defined by each plugin. \"\"\" return self . registered_plugins [ plugin_name ] post_visible_setup () \u00b6 Initialize registered plugins. Source code in pychamber/main_window.py 109 110 111 112 113 114 115 116 def post_visible_setup ( self ) -> None : \"\"\"Initialize registered plugins.\"\"\" LOG . debug ( \"Running post-visible setups\" ) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _post_visible_setup () self . statusBar () . showMessage ( \"Welcome to PyChamber!\" , 2000 ) register_plugin ( plugin ) \u00b6 Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Parameters: Name Type Description Default plugin PyChamberPlugin plugin to register required Source code in pychamber/main_window.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Arguments: plugin: plugin to register \"\"\" assert plugin . NAME is not None if plugin . NAME in self . registered_plugins : raise PyChamberPluginError ( f \"A plugin is already registered with { plugin . NAME } \" ) plugin . _register () self . registered_plugins [ plugin . NAME ] = plugin if isinstance ( plugin , PyChamberPanelPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to panel\" ) self . panel_layout . addWidget ( plugin ) elif isinstance ( plugin , PyChamberPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to right side\" ) self . right_side_layout . addWidget ( plugin ) setup () \u00b6 Setup the window's menu and widgets. Source code in pychamber/main_window.py 104 105 106 107 def setup ( self ) -> None : \"\"\"Setup the window's menu and widgets.\"\"\" self . _setup_menu () self . _add_widgets () unregister_plugin ( plugin ) \u00b6 Remove a plugin from PyChamber (NOT IMPLEMENTED). Parameters: Name Type Description Default plugin PyChamberPlugin plugin to remove required Source code in pychamber/main_window.py 174 175 176 177 178 179 180 def unregister_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Remove a plugin from PyChamber (NOT IMPLEMENTED). Arguments: plugin: plugin to remove \"\"\" raise NotImplementedError","title":"Main window"},{"location":"reference/main_window/#pychamber.main_window.MainWindow","text":"Bases: QMainWindow PyChamber. This is the main window of PyChamber. It is responsible for handling user interactions, managing plugins, and providing a menu and status bar. Source code in pychamber/main_window.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class MainWindow ( QMainWindow ): \"\"\"PyChamber. This is the main window of PyChamber. It is responsible for handling user interactions, managing plugins, and providing a menu and status bar. \"\"\" REQUIRED_PLUGINS = [ plugins . AnalyzerPlugin , plugins . CalibrationPlugin , plugins . ExperimentPlugin , plugins . PositionerPlugin , plugins . PlotsPlugin , ] \"\"\"list(PyChamberPlugin): List of minimum plugins required to run PyChamber\"\"\" def __init__ ( self , * args ) -> None : \"\"\"Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. \"\"\" super () . __init__ ( * args ) LOG . debug ( \"Constructing MainWindow...\" ) self . setWindowTitle ( \"PyChamber\" ) self . setWindowIcon ( QIcon ( \":/logo.png\" )) self . main_widget = QWidget ( self ) self . setCentralWidget ( self . main_widget ) self . main_layout = QHBoxLayout ( self . main_widget ) self . registered_plugins : Dict [ str , PyChamberPlugin ] = {} def _on_save_triggered ( self ) -> None : LOG . debug ( \"Launching save dialog...\" ) experiment = cast ( plugins . ExperimentPlugin , self . get_plugin ( \"experiment\" )) ntwk_model = experiment . ntwk_model if len ( ntwk_model ) == 0 : QMessageBox . warning ( self , \"No data\" , \"No data to save. Run an experiment first.\" ) return to_save = ntwk_model . data () save_name , _ = QFileDialog . getSaveFileName () if save_name != \"\" : with open ( save_name , 'wb' ) as save_file : pickle . dump ( to_save , save_file ) def _on_load_triggered ( self ) -> None : # TODO: Handle NetworkModel.data_loaded LOG . debug ( \"Launching load dialog...\" ) experiment = cast ( plugins . ExperimentPlugin , self . get_plugin ( \"experiment\" )) ntwk_model = experiment . ntwk_model file_name , _ = QFileDialog . getOpenFileName () if file_name != \"\" : try : LOG . debug ( f \"Loading { file_name } \" ) with open ( file_name , 'rb' ) as ff : data = pickle . load ( ff ) ntwk_model . load_data ( data ) except Exception : QMessageBox . critical ( self , \"Invalid File\" , \"The specified file is invalid\" ) return def _on_settings_triggered ( self ) -> None : LOG . debug ( \"Launching settings dialog...\" ) SettingsDialog . display () def _on_python_interpreter_triggered ( self ) -> None : LOG . debug ( \"Launching Python interpreter...\" ) def setup ( self ) -> None : \"\"\"Setup the window's menu and widgets.\"\"\" self . _setup_menu () self . _add_widgets () def post_visible_setup ( self ) -> None : \"\"\"Initialize registered plugins.\"\"\" LOG . debug ( \"Running post-visible setups\" ) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _post_visible_setup () self . statusBar () . showMessage ( \"Welcome to PyChamber!\" , 2000 ) def center ( self ) -> None : \"\"\"Center the window.\"\"\" qr = self . frameGeometry () cp = QDesktopWidget () . availableGeometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ()) def closeEvent ( self , event : QCloseEvent ) -> None : \"\"\"Warn the user on close. Arguments: event: the event that triggered the close. \"\"\" LOG . debug ( \"Close event triggered\" ) warning = QMessageBox () warning . setStandardButtons ( QMessageBox . Yes | QMessageBox . Cancel ) warning . setDefaultButton ( QMessageBox . Cancel ) warning . setText ( \"Are you sure you want to quit? \\n (Any unsaved data will be LOST)\" ) resp = warning . exec_ () if resp == QMessageBox . Yes : LOG . debug ( \"Close event accepted\" ) del self . settings # Saves settings super () . closeEvent ( event ) else : LOG . debug ( \"Close event canceled\" ) event . ignore () def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Arguments: plugin: plugin to register \"\"\" assert plugin . NAME is not None if plugin . NAME in self . registered_plugins : raise PyChamberPluginError ( f \"A plugin is already registered with { plugin . NAME } \" ) plugin . _register () self . registered_plugins [ plugin . NAME ] = plugin if isinstance ( plugin , PyChamberPanelPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to panel\" ) self . panel_layout . addWidget ( plugin ) elif isinstance ( plugin , PyChamberPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to right side\" ) self . right_side_layout . addWidget ( plugin ) def unregister_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Remove a plugin from PyChamber (NOT IMPLEMENTED). Arguments: plugin: plugin to remove \"\"\" raise NotImplementedError def get_plugin ( self , plugin_name : str ) -> PyChamberPlugin : \"\"\"Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Arguments: plugin_name: name of the plugin. This is defined by each plugin. \"\"\" return self . registered_plugins [ plugin_name ] def _setup_menu ( self ) -> None : LOG . debug ( \"Setting up menu...\" ) self . menu = self . menuBar () self . file = self . menu . addMenu ( \"File\" ) self . save = self . file . addAction ( \"Save\" ) self . load = self . file . addAction ( \"Load\" ) self . file . addSeparator () self . settings = self . file . addAction ( \"Settings\" ) self . file . addSeparator () self . quit = self . file . addAction ( \"Quit\" ) self . save . triggered . connect ( self . _on_save_triggered ) self . load . triggered . connect ( self . _on_load_triggered ) self . settings . triggered . connect ( self . _on_settings_triggered ) self . quit . triggered . connect ( self . close ) self . tools = self . menu . addMenu ( \"Tools\" ) self . python_interpreter = self . tools . addAction ( \"Python Terminal\" ) self . python_interpreter . triggered . connect ( self . _on_python_interpreter_triggered ) self . help = self . menu . addMenu ( \"Help\" ) self . bug = self . help . addAction ( \"Submit a Bug\" ) self . help . addSeparator () self . about = self . help . addAction ( \"About\" ) self . log = self . help . addAction ( \"View Log\" ) bug_report_url = \"https://github.com/HRG-Lab/PyChamber/issues/new\" self . bug . triggered . connect ( lambda : webbrowser . open ( bug_report_url )) self . about . triggered . connect ( AboutPyChamberDialog . display ) self . log . triggered . connect ( LogViewer . display ) def _add_widgets ( self ) -> None : LOG . debug ( \"Setting up widgets...\" ) self . panel_scroll_area = QScrollArea ( widgetResizable = True ) self . panel_widget = QWidget () self . panel_scroll_area . setWidget ( self . panel_widget ) self . panel_layout = QVBoxLayout ( self . panel_widget ) self . panel_scroll_area . setVerticalScrollBarPolicy ( Qt . ScrollBarAlwaysOn ) self . panel_scroll_area . setHorizontalScrollBarPolicy ( Qt . ScrollBarAlwaysOff ) self . right_side_layout = QVBoxLayout () self . main_layout . addWidget ( self . panel_scroll_area ) self . main_layout . addLayout ( self . right_side_layout ) for plugin in self . REQUIRED_PLUGINS : self . register_plugin ( cast ( PyChamberPlugin , plugin ( self ))) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _setup () self . panel_layout . addStretch () self . panel_scroll_area . setFixedWidth ( self . panel_widget . minimumSizeHint () . width () + self . panel_scroll_area . verticalScrollBar () . sizeHint () . width () )","title":"MainWindow"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.REQUIRED_PLUGINS","text":"list(PyChamberPlugin): List of minimum plugins required to run PyChamber","title":"REQUIRED_PLUGINS"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.__init__","text":"Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. Source code in pychamber/main_window.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , * args ) -> None : \"\"\"Create the PyChamber main window. Does some basic initialization, but expects the launching (in app.py) to call methods to do the actual setup. \"\"\" super () . __init__ ( * args ) LOG . debug ( \"Constructing MainWindow...\" ) self . setWindowTitle ( \"PyChamber\" ) self . setWindowIcon ( QIcon ( \":/logo.png\" )) self . main_widget = QWidget ( self ) self . setCentralWidget ( self . main_widget ) self . main_layout = QHBoxLayout ( self . main_widget ) self . registered_plugins : Dict [ str , PyChamberPlugin ] = {}","title":"__init__()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.center","text":"Center the window. Source code in pychamber/main_window.py 118 119 120 121 122 123 def center ( self ) -> None : \"\"\"Center the window.\"\"\" qr = self . frameGeometry () cp = QDesktopWidget () . availableGeometry () . center () qr . moveCenter ( cp ) self . move ( qr . topLeft ())","title":"center()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.closeEvent","text":"Warn the user on close. Parameters: Name Type Description Default event QCloseEvent the event that triggered the close. required Source code in pychamber/main_window.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def closeEvent ( self , event : QCloseEvent ) -> None : \"\"\"Warn the user on close. Arguments: event: the event that triggered the close. \"\"\" LOG . debug ( \"Close event triggered\" ) warning = QMessageBox () warning . setStandardButtons ( QMessageBox . Yes | QMessageBox . Cancel ) warning . setDefaultButton ( QMessageBox . Cancel ) warning . setText ( \"Are you sure you want to quit? \\n (Any unsaved data will be LOST)\" ) resp = warning . exec_ () if resp == QMessageBox . Yes : LOG . debug ( \"Close event accepted\" ) del self . settings # Saves settings super () . closeEvent ( event ) else : LOG . debug ( \"Close event canceled\" ) event . ignore ()","title":"closeEvent()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.get_plugin","text":"Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Parameters: Name Type Description Default plugin_name str name of the plugin. This is defined by each plugin. required Source code in pychamber/main_window.py 182 183 184 185 186 187 188 189 190 191 192 def get_plugin ( self , plugin_name : str ) -> PyChamberPlugin : \"\"\"Retrieve plugin instance. All plugins are registered in the MainWindow and have a reference to it. Plugins that need to interoperate with other plugins can use this function to retrieve those plugin instances. Arguments: plugin_name: name of the plugin. This is defined by each plugin. \"\"\" return self . registered_plugins [ plugin_name ]","title":"get_plugin()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.post_visible_setup","text":"Initialize registered plugins. Source code in pychamber/main_window.py 109 110 111 112 113 114 115 116 def post_visible_setup ( self ) -> None : \"\"\"Initialize registered plugins.\"\"\" LOG . debug ( \"Running post-visible setups\" ) to_init = list ( self . registered_plugins . values ()) for plugin in to_init : plugin . _post_visible_setup () self . statusBar () . showMessage ( \"Welcome to PyChamber!\" , 2000 )","title":"post_visible_setup()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.register_plugin","text":"Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Parameters: Name Type Description Default plugin PyChamberPlugin plugin to register required Source code in pychamber/main_window.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Register a plugin. This registers the plugin with the application (including settings). All panel plugins are added to the left-side scrolling panel and any other plugins are added to the main layout. This might change for plugins the may not want to be in either place (e.g. tools accessible from the menu) For more information about creating plugins, see the plugins module documentation. Arguments: plugin: plugin to register \"\"\" assert plugin . NAME is not None if plugin . NAME in self . registered_plugins : raise PyChamberPluginError ( f \"A plugin is already registered with { plugin . NAME } \" ) plugin . _register () self . registered_plugins [ plugin . NAME ] = plugin if isinstance ( plugin , PyChamberPanelPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to panel\" ) self . panel_layout . addWidget ( plugin ) elif isinstance ( plugin , PyChamberPlugin ): LOG . debug ( f \"Adding { plugin . NAME } to right side\" ) self . right_side_layout . addWidget ( plugin )","title":"register_plugin()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.setup","text":"Setup the window's menu and widgets. Source code in pychamber/main_window.py 104 105 106 107 def setup ( self ) -> None : \"\"\"Setup the window's menu and widgets.\"\"\" self . _setup_menu () self . _add_widgets ()","title":"setup()"},{"location":"reference/main_window/#pychamber.main_window.MainWindow.unregister_plugin","text":"Remove a plugin from PyChamber (NOT IMPLEMENTED). Parameters: Name Type Description Default plugin PyChamberPlugin plugin to remove required Source code in pychamber/main_window.py 174 175 176 177 178 179 180 def unregister_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Remove a plugin from PyChamber (NOT IMPLEMENTED). Arguments: plugin: plugin to remove \"\"\" raise NotImplementedError","title":"unregister_plugin()"},{"location":"reference/models/","text":"Models used throughout PyChamber.","title":"Models"},{"location":"reference/plugins/","text":"The plugin system of PyChamber as well as the default plugins. The functionality of PyChamber is made through a set of plugins with the potential for users to add new plugins in the future.","title":"Plugins"},{"location":"reference/polarization/","text":"Defines the Polarization class. Polarization dataclass \u00b6 A single polarization with name and parameter. A parameter is the actual value that is being measured e.g. S21 Source code in pychamber/polarization.py 5 6 7 8 9 10 11 12 13 @dataclass class Polarization : \"\"\"A single polarization with name and parameter. A parameter is the actual value that is being measured e.g. S21 \"\"\" label : str param : str","title":"Polarization"},{"location":"reference/polarization/#pychamber.polarization.Polarization","text":"A single polarization with name and parameter. A parameter is the actual value that is being measured e.g. S21 Source code in pychamber/polarization.py 5 6 7 8 9 10 11 12 13 @dataclass class Polarization : \"\"\"A single polarization with name and parameter. A parameter is the actual value that is being measured e.g. S21 \"\"\" label : str param : str","title":"Polarization"},{"location":"reference/settings/","text":"Persistent application-wide settings. Defines the SETTINGS global that can be accessed throughout the application. Each plugin gets its own section e.g. the positioner plugin settings will be: SETTINGS[\"positioner/az-start\"] SETTINGS[\"positioner/az-stop\"] ... The defaults are defined per plugin and populate the global defaults when registered. Settings \u00b6 Bases: QSettings The actual settings object. Attributes: Name Type Description settings_changed Signal Source code in pychamber/settings.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Settings ( QSettings ): \"\"\"The actual settings object. Attributes: settings_changed: Signal \"\"\" settings_changed = pyqtSignal ( str ) _defaults : Dict = { \"pyconsole/theme\" : \"nightowl-light\" } def __init__ ( self , parent = None ) -> None : \"\"\"Create the settings object. Arguments: parent: parent QWidget \"\"\" super () . __init__ ( ORG_NAME , APP_NAME , parent ) def __getitem__ ( self , index : str ) -> Any : \"\"\"Retrieve a setting or its default if not set. Arguments: index: setting name \"\"\" return self . value ( index , self . _defaults [ index ]) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Change a setting. Emits a settings_changed signal. Arguments: key: setting name value: new value \"\"\" LOG . debug ( f \"Updating setting: { key } = { value } \" ) self . setValue ( key , value ) self . settings_changed . emit ( key ) def __contains__ ( self , elem : str ) -> bool : \"\"\"Enable 'in' operator. Arguments: elem: element to check existence of \"\"\" return elem in self . childGroups () def setval ( self , key : str , value : Any ) -> None : \"\"\"This is needed to connect setting changes to signals with a lambda. Arguments: key: setting name value: new value \"\"\" self [ key ] = value def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Arguments: plugin: The plugin to register \"\"\" assert plugin . NAME is not None LOG . debug ( f \"Registering plugin: { plugin . NAME } \" ) self . beginGroup ( plugin . NAME ) for key , val in plugin . CONFIG . items (): self . _defaults [ plugin . NAME + \"/\" + key ] = val if self . contains ( key ): plugin . CONFIG [ key ] = self . value ( key ) self . endGroup () __contains__ ( elem ) \u00b6 Enable 'in' operator. Parameters: Name Type Description Default elem str element to check existence of required Source code in pychamber/settings.py 67 68 69 70 71 72 73 def __contains__ ( self , elem : str ) -> bool : \"\"\"Enable 'in' operator. Arguments: elem: element to check existence of \"\"\" return elem in self . childGroups () __getitem__ ( index ) \u00b6 Retrieve a setting or its default if not set. Parameters: Name Type Description Default index str setting name required Source code in pychamber/settings.py 48 49 50 51 52 53 54 def __getitem__ ( self , index : str ) -> Any : \"\"\"Retrieve a setting or its default if not set. Arguments: index: setting name \"\"\" return self . value ( index , self . _defaults [ index ]) __init__ ( parent = None ) \u00b6 Create the settings object. Parameters: Name Type Description Default parent parent QWidget None Source code in pychamber/settings.py 40 41 42 43 44 45 46 def __init__ ( self , parent = None ) -> None : \"\"\"Create the settings object. Arguments: parent: parent QWidget \"\"\" super () . __init__ ( ORG_NAME , APP_NAME , parent ) __setitem__ ( key , value ) \u00b6 Change a setting. Emits a settings_changed signal. Parameters: Name Type Description Default key str setting name required value Any new value required Source code in pychamber/settings.py 56 57 58 59 60 61 62 63 64 65 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Change a setting. Emits a settings_changed signal. Arguments: key: setting name value: new value \"\"\" LOG . debug ( f \"Updating setting: { key } = { value } \" ) self . setValue ( key , value ) self . settings_changed . emit ( key ) register_plugin ( plugin ) \u00b6 Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Parameters: Name Type Description Default plugin PyChamberPlugin The plugin to register required Source code in pychamber/settings.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Arguments: plugin: The plugin to register \"\"\" assert plugin . NAME is not None LOG . debug ( f \"Registering plugin: { plugin . NAME } \" ) self . beginGroup ( plugin . NAME ) for key , val in plugin . CONFIG . items (): self . _defaults [ plugin . NAME + \"/\" + key ] = val if self . contains ( key ): plugin . CONFIG [ key ] = self . value ( key ) self . endGroup () setval ( key , value ) \u00b6 This is needed to connect setting changes to signals with a lambda. Parameters: Name Type Description Default key str setting name required value Any new value required Source code in pychamber/settings.py 75 76 77 78 79 80 81 82 def setval ( self , key : str , value : Any ) -> None : \"\"\"This is needed to connect setting changes to signals with a lambda. Arguments: key: setting name value: new value \"\"\" self [ key ] = value","title":"Settings"},{"location":"reference/settings/#pychamber.settings.Settings","text":"Bases: QSettings The actual settings object. Attributes: Name Type Description settings_changed Signal Source code in pychamber/settings.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class Settings ( QSettings ): \"\"\"The actual settings object. Attributes: settings_changed: Signal \"\"\" settings_changed = pyqtSignal ( str ) _defaults : Dict = { \"pyconsole/theme\" : \"nightowl-light\" } def __init__ ( self , parent = None ) -> None : \"\"\"Create the settings object. Arguments: parent: parent QWidget \"\"\" super () . __init__ ( ORG_NAME , APP_NAME , parent ) def __getitem__ ( self , index : str ) -> Any : \"\"\"Retrieve a setting or its default if not set. Arguments: index: setting name \"\"\" return self . value ( index , self . _defaults [ index ]) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Change a setting. Emits a settings_changed signal. Arguments: key: setting name value: new value \"\"\" LOG . debug ( f \"Updating setting: { key } = { value } \" ) self . setValue ( key , value ) self . settings_changed . emit ( key ) def __contains__ ( self , elem : str ) -> bool : \"\"\"Enable 'in' operator. Arguments: elem: element to check existence of \"\"\" return elem in self . childGroups () def setval ( self , key : str , value : Any ) -> None : \"\"\"This is needed to connect setting changes to signals with a lambda. Arguments: key: setting name value: new value \"\"\" self [ key ] = value def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Arguments: plugin: The plugin to register \"\"\" assert plugin . NAME is not None LOG . debug ( f \"Registering plugin: { plugin . NAME } \" ) self . beginGroup ( plugin . NAME ) for key , val in plugin . CONFIG . items (): self . _defaults [ plugin . NAME + \"/\" + key ] = val if self . contains ( key ): plugin . CONFIG [ key ] = self . value ( key ) self . endGroup ()","title":"Settings"},{"location":"reference/settings/#pychamber.settings.Settings.__contains__","text":"Enable 'in' operator. Parameters: Name Type Description Default elem str element to check existence of required Source code in pychamber/settings.py 67 68 69 70 71 72 73 def __contains__ ( self , elem : str ) -> bool : \"\"\"Enable 'in' operator. Arguments: elem: element to check existence of \"\"\" return elem in self . childGroups ()","title":"__contains__()"},{"location":"reference/settings/#pychamber.settings.Settings.__getitem__","text":"Retrieve a setting or its default if not set. Parameters: Name Type Description Default index str setting name required Source code in pychamber/settings.py 48 49 50 51 52 53 54 def __getitem__ ( self , index : str ) -> Any : \"\"\"Retrieve a setting or its default if not set. Arguments: index: setting name \"\"\" return self . value ( index , self . _defaults [ index ])","title":"__getitem__()"},{"location":"reference/settings/#pychamber.settings.Settings.__init__","text":"Create the settings object. Parameters: Name Type Description Default parent parent QWidget None Source code in pychamber/settings.py 40 41 42 43 44 45 46 def __init__ ( self , parent = None ) -> None : \"\"\"Create the settings object. Arguments: parent: parent QWidget \"\"\" super () . __init__ ( ORG_NAME , APP_NAME , parent )","title":"__init__()"},{"location":"reference/settings/#pychamber.settings.Settings.__setitem__","text":"Change a setting. Emits a settings_changed signal. Parameters: Name Type Description Default key str setting name required value Any new value required Source code in pychamber/settings.py 56 57 58 59 60 61 62 63 64 65 def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Change a setting. Emits a settings_changed signal. Arguments: key: setting name value: new value \"\"\" LOG . debug ( f \"Updating setting: { key } = { value } \" ) self . setValue ( key , value ) self . settings_changed . emit ( key )","title":"__setitem__()"},{"location":"reference/settings/#pychamber.settings.Settings.register_plugin","text":"Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Parameters: Name Type Description Default plugin PyChamberPlugin The plugin to register required Source code in pychamber/settings.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def register_plugin ( self , plugin : PyChamberPlugin ) -> None : \"\"\"Creatings a settings entry for a new plugin and populates defaults. If the setting already exists, it is set in the plugin, otherwise the default value FROM the plugin's defined defaults is saved to the application settings. Arguments: plugin: The plugin to register \"\"\" assert plugin . NAME is not None LOG . debug ( f \"Registering plugin: { plugin . NAME } \" ) self . beginGroup ( plugin . NAME ) for key , val in plugin . CONFIG . items (): self . _defaults [ plugin . NAME + \"/\" + key ] = val if self . contains ( key ): plugin . CONFIG [ key ] = self . value ( key ) self . endGroup ()","title":"register_plugin()"},{"location":"reference/settings/#pychamber.settings.Settings.setval","text":"This is needed to connect setting changes to signals with a lambda. Parameters: Name Type Description Default key str setting name required value Any new value required Source code in pychamber/settings.py 75 76 77 78 79 80 81 82 def setval ( self , key : str , value : Any ) -> None : \"\"\"This is needed to connect setting changes to signals with a lambda. Arguments: key: setting name value: new value \"\"\" self [ key ] = value","title":"setval()"},{"location":"reference/utils/","text":"","title":"Utils"},{"location":"reference/widgets/","text":"Contains all of the widgets used in PyChamber. Plugins can use these widgets but any widgets specific to a plugin should local to that plugin.","title":"Widgets"}]}