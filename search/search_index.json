{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } .md-main { flex-grow: 1; } .md-main__inner { max-width: 800px; } Run anechoic chamber experiments from Python! PyChamber is a Python program written with scikit-rf , pyqtgraph , and Qt to provide a modern and easy to use means of collecting anechoic chamber data. This was developed at Penn State using the anechoic chamber there, and so currently only supports that equipment. However, care has been taken to make PyChamber easily extensible with a plugin architecture. Beyond the GUI, PyChamber provides a simple library that enables the scripting of anechoic chamber measurements. This means if you were measure e.g. a phased array, you could iterate over all array weightings of interest and take measurements without ever having to touch any equipment. That interface is still being tested and iterated on, however an example of that type of measurment might look like: import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) cal = pychamber . Calibration . load ( \"ETSLindgren3164-10.pycal\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] # Name, S(a, b) thetas = np . arange ( - 180 , 181 , 1 ) phis = np . arange ( - 90 , 91 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) weights = np . array ([ # first array of weights # second array of weights ... ]) analyzer . ch1 . frequency = freq all_results = [] array = # However you setup your array for weight in weights : array . set_weights ( weight ) # Example weight setting experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () result . apply_calibration ( cal ) all_results . append ( result ) experiment.run() will scan through all positions and polarizations and return an ExperimentResult . While running, it will display status and progress as exampled below. Installing \u00b6 Right now, pychamber can only be installed from source. To do this, download the .whl file under relases (on the right) navigate to it in a terminal, and run pip install ./<pychamber wheel> Repository initiated with fpgmaas/cookiecutter-poetry .","title":"Home"},{"location":"#installing","text":"Right now, pychamber can only be installed from source. To do this, download the .whl file under relases (on the right) navigate to it in a terminal, and run pip install ./<pychamber wheel> Repository initiated with fpgmaas/cookiecutter-poetry .","title":"Installing"},{"location":"application/","text":"Using PyChamber \u00b6 The interface \u00b6 The PyChamber interface is split into two main sections. On the left, we have all of the controls. These include experiment setup, analyzer controls, experiment controls, and any additional controls that are part of loaded plugins. At the top of this section are the buttons used to start and abort measurements. On the right side is where all of the plots live. You can view multiple plots simultaneously, split them into a seperate window, and some plots allow you to have multiple traces per plot. Each plot contains controls that are only for its window. Plots are explained in further detail in plots . Controls \u00b6 The left side of the interface is where everything controlling measurements is housed. At the top are the important buttons to start or abort the various types of scans. Below these buttons are where all the other controls housed. Each section can be expanded or collapsed by clicking the name. The following sections are included by default: Experiment Analyzer Positioner Plugins can add additional controls to this section if appropriate. If any results have been taken or loaded, they will be displayed in a list at the bottom. Clicking any of these items will set the \"active\" result set. Only the active result can be shown in plots. If a result is not saved, an exclamation point will be displayed next to it. You can save it by clicking on it to make it active, then going to File->Save. PyChamber will warn you if you try to exit with any unsaved data. Experiment \u00b6 This section is where you setup the details of your experiment like the angular extents, polarizations, and calibration. It is import to note that \"Theta\" is defined as the angle from the +z-axis, and phi is the angle from the +x-axis along the x-y plane. Polarizations is where you set the name of each polarization (up to 2) and what S parameter from the network analyzer that polarization corresponds to. These dropdowns will not be active until you connect to an analyzer as connecting informs PyChamber how many ports the analyzer has (and thus the available measurable parameters) Calibration is where you can load a previously saved calibration file, view that calibration file, or run through a wizard to generate a new calibration file. Analyzer \u00b6 This section is where you can connect to a network analyzer, and set properties like the frequency, IF bandwidth, averaging, etc. More controls may become available in later versions of PyChamber, and certain controls may become hidden or shown based on the capabilities of the analyzer you connect to. For frequency fields, you can type either a number like 1000000000000 for 1 GHz, or you can just type '1 GHz' (withouth the quote marks). The command won't be sent to the analyzer until you press enter on the keyboard or change what field you're editing. Positioner \u00b6 This section is where you can connect to and control the positioner, or antenna mount. PyChamber should remember the last positioner for each different positioner model and update the displays once connected. The large number indicates the current position. The \"Step\" box controls how far the corresponding axis will move each time a jog button is pressed. Clicking the \"0\" button will return that axis to its zero position. You can also jog to a specific position by entering the desired angle (in degrees), then clicking the \"Check\" button. The \"Set 0,0\" button is used to define the origin. This is used for example, when you mount a new antenna under test and align it to the sense antenna. If you don't take care while doing this, your measurements will look askew. Finally, the \"Return to 0,0\" button will move both axes to their \"0\" position. If the positioner you connect to has additional capabilities, more controls related to those functions will be added to the bottom of this section. Plots \u00b6 Thanks to pyqtgraph , the plots are extremely flexible. Think of each plot as living in its own window along with its controls. By default, adding additional plots adds another tab, which you can navigate to by clicking. The title of each tab is controlled by the \"Title\" control for each plot. You can rearrange the plots however you wish by clicking and dragging. Dragging to the side until you see a vertical blue bar will move the split the window to the right or left. Dragging to the top or bottom until you see a horizontal blue bar will split the window to the top or bottom. If you already have multiple plots displayed in split windows, you can drag one on top of another until you see a blue square in the middle to add the plot you're dragging as a tab with the plot you drag it onto. Finally, if you double click the title bar, the plot will split into its own seperate window. Closing the window will add the plot back to the main window. All plots have controls that are specific to the plot type. These are shown on the right when a new plot is created, and can be hidden / shown by clicking the long vertical grey button. All but the 3D plot allow exporting to various formats by right clicking. There are 4 types of plots available: Polar, Rectangular, Contour, and 3D. Polar Plots \u00b6 The \"Angular Variable\" dropdown controls what variable is on the angular axis. The \"R Variable\" dropdown controls what variable is the radial variable. Right now, you can only plot either linear or db magnitude. \"Zero location\" sets where 0 degrees is located. In the image above, 0 is set to -90, placing the 0 degree location at the top of the plot. \"R Minimum\", \"R Maximum\", and \"R Step\" all control the grid. If any value results in too many radial circles, the values will be updated automatically to something more sensible. You can add up to four traces by clicking the \"Add Trace\" button. Each trace can display uncalibrated / calibrated data, for a specific frequency, polarization, and either theta or phi depending on what variable is chosen as the angular variable. Traces can be deleted by clicking the X button on the right of each trace. Rectangular Plots \u00b6 The rectangular plots are more self explanatory. Currently, the available x-axis variables are: Frequency, Theta, and Phi, and the available y-axis variables are: Magnitude [linear/dB] and Phase [deg / deg unwrapped] You can add up to two traces by clicking the \"Add Trace\" button. Each trace can display uncalibrated / calibrated data, a specific polarization, and some combination of theta, phi, frequency depending on what variable is chosen as the x-axis. Traces can be deleted by clicking the X button on the right of each trace. Unlike polar plots, rectangular plots can be zoomed in or out, panned, etc using the mouse. Contour Plots \u00b6 Contour plots show 3 dimensional data with the third dimension show as a color gradient. Right now, PyChamber only allows you to plot either linear or dB magnitude. Other options include: \"Frequency\": what frequency to plot \"Polarization\": what polarization to plot \"Colormap\": what colormap to use to plot data. There are a lot. The most commonly used are at the top, and the default is the \"cividis\" colormap which was designed to be a perceptually uniform in color and grayscale and to be friendly to those with color vision defeciency. \"Z Minimum\" and \"Z Maximum\" change the scale. Values below the minimum are mapped to the minimum value, and values above the maximum are mapped to the maximum. \"Calibrated\" sets whether the displayed data is raw or calibrated (assuming calibrated data is available) \"Isolines\" sets whether or not to also display isovalue lines, which are lines along which values are equivalent (think of topographic maps where lines show altitude) 3D Plots \u00b6 3D plots are, obviously, 3 dimensional plots. The first time you create a 3D plot, PyChamber has to initiate its 3D graphics backend, so you may see the application look like it restarts. You can view data either as a cartesian plot, or a sphercal plot. In either view, you can use the mouse to move around and zoom in or out. There are the following controls: \"Frequency\": what frequency to plot \"Polarization\": what polarization to plot \"Colormap\": what colormap to use to plot data. There are a lot. The most commonly used are at the top, and the default is the \"cividis\" colormap which was designed to be a perceptually uniform in color and grayscale and to be friendly to those with color vision defeciency. \"R Minimum\" and \"R Maximum\" change the scale. Values below the minimum are mapped to the minimum value, and values above the maximum are mapped to the maximum. \"Calibrated\" sets whether the displayed data is raw or calibrated (assuming calibrated data is available)","title":"Using PyChamber"},{"location":"application/#using-pychamber","text":"","title":"Using PyChamber"},{"location":"application/#the-interface","text":"The PyChamber interface is split into two main sections. On the left, we have all of the controls. These include experiment setup, analyzer controls, experiment controls, and any additional controls that are part of loaded plugins. At the top of this section are the buttons used to start and abort measurements. On the right side is where all of the plots live. You can view multiple plots simultaneously, split them into a seperate window, and some plots allow you to have multiple traces per plot. Each plot contains controls that are only for its window. Plots are explained in further detail in plots .","title":"The interface"},{"location":"application/#controls","text":"The left side of the interface is where everything controlling measurements is housed. At the top are the important buttons to start or abort the various types of scans. Below these buttons are where all the other controls housed. Each section can be expanded or collapsed by clicking the name. The following sections are included by default: Experiment Analyzer Positioner Plugins can add additional controls to this section if appropriate. If any results have been taken or loaded, they will be displayed in a list at the bottom. Clicking any of these items will set the \"active\" result set. Only the active result can be shown in plots. If a result is not saved, an exclamation point will be displayed next to it. You can save it by clicking on it to make it active, then going to File->Save. PyChamber will warn you if you try to exit with any unsaved data.","title":"Controls"},{"location":"application/#experiment","text":"This section is where you setup the details of your experiment like the angular extents, polarizations, and calibration. It is import to note that \"Theta\" is defined as the angle from the +z-axis, and phi is the angle from the +x-axis along the x-y plane. Polarizations is where you set the name of each polarization (up to 2) and what S parameter from the network analyzer that polarization corresponds to. These dropdowns will not be active until you connect to an analyzer as connecting informs PyChamber how many ports the analyzer has (and thus the available measurable parameters) Calibration is where you can load a previously saved calibration file, view that calibration file, or run through a wizard to generate a new calibration file.","title":"Experiment"},{"location":"application/#analyzer","text":"This section is where you can connect to a network analyzer, and set properties like the frequency, IF bandwidth, averaging, etc. More controls may become available in later versions of PyChamber, and certain controls may become hidden or shown based on the capabilities of the analyzer you connect to. For frequency fields, you can type either a number like 1000000000000 for 1 GHz, or you can just type '1 GHz' (withouth the quote marks). The command won't be sent to the analyzer until you press enter on the keyboard or change what field you're editing.","title":"Analyzer"},{"location":"application/#positioner","text":"This section is where you can connect to and control the positioner, or antenna mount. PyChamber should remember the last positioner for each different positioner model and update the displays once connected. The large number indicates the current position. The \"Step\" box controls how far the corresponding axis will move each time a jog button is pressed. Clicking the \"0\" button will return that axis to its zero position. You can also jog to a specific position by entering the desired angle (in degrees), then clicking the \"Check\" button. The \"Set 0,0\" button is used to define the origin. This is used for example, when you mount a new antenna under test and align it to the sense antenna. If you don't take care while doing this, your measurements will look askew. Finally, the \"Return to 0,0\" button will move both axes to their \"0\" position. If the positioner you connect to has additional capabilities, more controls related to those functions will be added to the bottom of this section.","title":"Positioner"},{"location":"application/#plots","text":"Thanks to pyqtgraph , the plots are extremely flexible. Think of each plot as living in its own window along with its controls. By default, adding additional plots adds another tab, which you can navigate to by clicking. The title of each tab is controlled by the \"Title\" control for each plot. You can rearrange the plots however you wish by clicking and dragging. Dragging to the side until you see a vertical blue bar will move the split the window to the right or left. Dragging to the top or bottom until you see a horizontal blue bar will split the window to the top or bottom. If you already have multiple plots displayed in split windows, you can drag one on top of another until you see a blue square in the middle to add the plot you're dragging as a tab with the plot you drag it onto. Finally, if you double click the title bar, the plot will split into its own seperate window. Closing the window will add the plot back to the main window. All plots have controls that are specific to the plot type. These are shown on the right when a new plot is created, and can be hidden / shown by clicking the long vertical grey button. All but the 3D plot allow exporting to various formats by right clicking. There are 4 types of plots available: Polar, Rectangular, Contour, and 3D.","title":"Plots"},{"location":"application/#polar-plots","text":"The \"Angular Variable\" dropdown controls what variable is on the angular axis. The \"R Variable\" dropdown controls what variable is the radial variable. Right now, you can only plot either linear or db magnitude. \"Zero location\" sets where 0 degrees is located. In the image above, 0 is set to -90, placing the 0 degree location at the top of the plot. \"R Minimum\", \"R Maximum\", and \"R Step\" all control the grid. If any value results in too many radial circles, the values will be updated automatically to something more sensible. You can add up to four traces by clicking the \"Add Trace\" button. Each trace can display uncalibrated / calibrated data, for a specific frequency, polarization, and either theta or phi depending on what variable is chosen as the angular variable. Traces can be deleted by clicking the X button on the right of each trace.","title":"Polar Plots"},{"location":"application/#rectangular-plots","text":"The rectangular plots are more self explanatory. Currently, the available x-axis variables are: Frequency, Theta, and Phi, and the available y-axis variables are: Magnitude [linear/dB] and Phase [deg / deg unwrapped] You can add up to two traces by clicking the \"Add Trace\" button. Each trace can display uncalibrated / calibrated data, a specific polarization, and some combination of theta, phi, frequency depending on what variable is chosen as the x-axis. Traces can be deleted by clicking the X button on the right of each trace. Unlike polar plots, rectangular plots can be zoomed in or out, panned, etc using the mouse.","title":"Rectangular Plots"},{"location":"application/#contour-plots","text":"Contour plots show 3 dimensional data with the third dimension show as a color gradient. Right now, PyChamber only allows you to plot either linear or dB magnitude. Other options include: \"Frequency\": what frequency to plot \"Polarization\": what polarization to plot \"Colormap\": what colormap to use to plot data. There are a lot. The most commonly used are at the top, and the default is the \"cividis\" colormap which was designed to be a perceptually uniform in color and grayscale and to be friendly to those with color vision defeciency. \"Z Minimum\" and \"Z Maximum\" change the scale. Values below the minimum are mapped to the minimum value, and values above the maximum are mapped to the maximum. \"Calibrated\" sets whether the displayed data is raw or calibrated (assuming calibrated data is available) \"Isolines\" sets whether or not to also display isovalue lines, which are lines along which values are equivalent (think of topographic maps where lines show altitude)","title":"Contour Plots"},{"location":"application/#3d-plots","text":"3D plots are, obviously, 3 dimensional plots. The first time you create a 3D plot, PyChamber has to initiate its 3D graphics backend, so you may see the application look like it restarts. You can view data either as a cartesian plot, or a sphercal plot. In either view, you can use the mouse to move around and zoom in or out. There are the following controls: \"Frequency\": what frequency to plot \"Polarization\": what polarization to plot \"Colormap\": what colormap to use to plot data. There are a lot. The most commonly used are at the top, and the default is the \"cividis\" colormap which was designed to be a perceptually uniform in color and grayscale and to be friendly to those with color vision defeciency. \"R Minimum\" and \"R Maximum\" change the scale. Values below the minimum are mapped to the minimum value, and values above the maximum are mapped to the maximum. \"Calibrated\" sets whether the displayed data is raw or calibrated (assuming calibrated data is available)","title":"3D Plots"},{"location":"scripting/","text":"Taking Measurements with Python \u00b6 In addition to the graphical user interface, pychamber can in Python scripts. This can be extremely useful when measuring things like antenna arrays where you want to take a measurement, change the state of the array, take another measurement, etc. Shown below are examples of various kinds of measurements. Basic Measurement \u00b6 This example shows how you can take a simple measurement with the following setup and save it to result.mdif : One polarization (Horizontal) that corresponds to S21 No calibration \\(-90 \\leq \\theta \\leq 90\\) in 1 degree increments \\(-180 \\leq \\varphi \\leq 180\\) in 1 degree increments Frequency: 1 GHz - 3 GHz, 401 points import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] # Name, S(a, b) thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () result . save ( 'result.mdif' ) Calibrated Measurement \u00b6 This example shows how you can take a simple measurement as above, but this time applying a calibration. Applying a calibration does not edit the raw data, instead appending the calibrated values to the existing data. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () cal = pychamber . Calibration . load ( \"example_calibration.pycal\" ) result . apply_calibration ( cal ) result . save ( 'result.mdif' ) Measurement One Cut Plane \u00b6 Again, using the same setup as above, but only measuring the theta cut. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . array ([ 0 ]) # <-- CHANGED! freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () cal = pychamber . Calibration . load ( \"example_calibration.pycal\" ) result . apply_calibration ( cal ) result . save ( 'result.mdif' ) Array Measurement \u00b6 Similar setup to the previous, but with multiple polarizations, and changing array weights. This is accomplished by iterating over array weights, and saving to a new file for each state. This example assumes you have some other Python module providing an interface to changing a phased array's weights. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) analyzer . ch1 . frequency = freq array = # Some class that provides an interface to an array weights = np . array ([ # first array of weights # second array of weights ... ]) for i , weight in enumerate ( weights ): array . set_weights ( weight ) # Example weight setting experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () result . apply_calibration ( cal ) result . save ( f \"run { i } .mdif\" )","title":"Scripting"},{"location":"scripting/#taking-measurements-with-python","text":"In addition to the graphical user interface, pychamber can in Python scripts. This can be extremely useful when measuring things like antenna arrays where you want to take a measurement, change the state of the array, take another measurement, etc. Shown below are examples of various kinds of measurements.","title":"Taking Measurements with Python"},{"location":"scripting/#basic-measurement","text":"This example shows how you can take a simple measurement with the following setup and save it to result.mdif : One polarization (Horizontal) that corresponds to S21 No calibration \\(-90 \\leq \\theta \\leq 90\\) in 1 degree increments \\(-180 \\leq \\varphi \\leq 180\\) in 1 degree increments Frequency: 1 GHz - 3 GHz, 401 points import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] # Name, S(a, b) thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () result . save ( 'result.mdif' )","title":"Basic Measurement"},{"location":"scripting/#calibrated-measurement","text":"This example shows how you can take a simple measurement as above, but this time applying a calibration. Applying a calibration does not edit the raw data, instead appending the calibrated values to the existing data. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () cal = pychamber . Calibration . load ( \"example_calibration.pycal\" ) result . apply_calibration ( cal ) result . save ( 'result.mdif' )","title":"Calibrated Measurement"},{"location":"scripting/#measurement-one-cut-plane","text":"Again, using the same setup as above, but only measuring the theta cut. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . array ([ 0 ]) # <-- CHANGED! freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) analyzer . ch1 . frequency = freq experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () cal = pychamber . Calibration . load ( \"example_calibration.pycal\" ) result . apply_calibration ( cal ) result . save ( 'result.mdif' )","title":"Measurement One Cut Plane"},{"location":"scripting/#array-measurement","text":"Similar setup to the previous, but with multiple polarizations, and changing array weights. This is accomplished by iterating over array weights, and saving to a new file for each state. This example assumes you have some other Python module providing an interface to changing a phased array's weights. import pychamber import skrf from skrf.vi.vna import keysight import numpy as np analyzer = keysight . PNA ( 'GPIB0::16::INSTR' ) positioner = pychamber . positioner . connect ( \"Diamond\" , \"D6050\" , \"COM3\" ) polarizations = [( \"Horizontal\" , 2 , 1 )] thetas = np . arange ( - 90 , 91 , 1 ) phis = np . arange ( - 180 , 181 , 1 ) freq = skrf . Frequency ( start = 1_000_000_000 , stop = 3_000_000_000 , npoints = 401 , unit = 'Hz' ) experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) analyzer . ch1 . frequency = freq array = # Some class that provides an interface to an array weights = np . array ([ # first array of weights # second array of weights ... ]) for i , weight in enumerate ( weights ): array . set_weights ( weight ) # Example weight setting experiment = pychamber . Experiment ( positioner , thetas , phis , polarizations , f ) result = experiment . run () result . apply_calibration ( cal ) result . save ( f \"run { i } .mdif\" )","title":"Array Measurement"},{"location":"reference/SUMMARY/","text":"pychamber api calibration experiment experiment_result math_fns settings positioner factory interface","title":"SUMMARY"},{"location":"reference/pychamber/","text":"","title":"pychamber"},{"location":"reference/pychamber/api/","text":"PluginInterface \u00b6 Interface for plugins to adhere to. When creating a new plugin, you must provide the initialize method, which is called to setup the plugin. initialize staticmethod \u00b6 initialize () Initialize the plugin PluginManager \u00b6 PluginManager () Manage plugins. You should not need to interact with this. A plugin manager is created to load plugins anytime you import pychamber. get_local_plugins \u00b6 get_local_plugins () Gets plugins provided by PyChamber. get_user_plugins \u00b6 get_user_plugins () Gets plugins provided by the user. import_plugin \u00b6 import_plugin ( name ) Import a plugin module load_plugins \u00b6 load_plugins () Initialize all registered plugins. This is where each plugin's initialize method is called.","title":"api"},{"location":"reference/pychamber/api/#pychamber.api.PluginInterface","text":"Interface for plugins to adhere to. When creating a new plugin, you must provide the initialize method, which is called to setup the plugin.","title":"PluginInterface"},{"location":"reference/pychamber/api/#pychamber.api.PluginInterface.initialize","text":"initialize () Initialize the plugin","title":"initialize()"},{"location":"reference/pychamber/api/#pychamber.api.PluginManager","text":"PluginManager () Manage plugins. You should not need to interact with this. A plugin manager is created to load plugins anytime you import pychamber.","title":"PluginManager"},{"location":"reference/pychamber/api/#pychamber.api.PluginManager.get_local_plugins","text":"get_local_plugins () Gets plugins provided by PyChamber.","title":"get_local_plugins()"},{"location":"reference/pychamber/api/#pychamber.api.PluginManager.get_user_plugins","text":"get_user_plugins () Gets plugins provided by the user.","title":"get_user_plugins()"},{"location":"reference/pychamber/api/#pychamber.api.PluginManager.import_plugin","text":"import_plugin ( name ) Import a plugin module","title":"import_plugin()"},{"location":"reference/pychamber/api/#pychamber.api.PluginManager.load_plugins","text":"load_plugins () Initialize all registered plugins. This is where each plugin's initialize method is called.","title":"load_plugins()"},{"location":"reference/pychamber/calibration/","text":"Calibration \u00b6 Calibration ( networks , notes = None ) A class containing data for a scalar substitution calibration. This kind of calibration is performed when you have an antenna with known performance. By measuring the antenna with your experiment setup, you can determine the difference between the expected performance and what you measure influenced by path loss, cable loss, etc. Additionally, notes can be stored with the calibration which can describe important contextual information about the setup as it existed when this calibration was created. When saved, this class is stored as a .mdif file, a text-based file format. Comments are stored using a specific delimiter ('@') to allow them to be differentiated from other comments in the file. To make it easier to differentiate calibrations from other data files, it is suggested to use the file extension .pycal Parameters: networks ( list [ skrf . Network ] | skrf . NetworkSet ) \u2013 The networks containing the calibration data notes ( list [ str ] | None ) \u2013 A list of strings containing notes. Each element is another line. frequency property \u00b6 frequency : skrf . Frequency The frequency range covered by this calibration networks property \u00b6 networks : skrf . NetworkSet The underlying networks that comprise this calibration polarizations property \u00b6 polarizations : list [ str ] The names of the polarizations in this calibration. get_polarization \u00b6 get_polarization ( polarization ) Get the Network for the named polarization. Parameters: polarization ( str ) \u2013 The name of the polarization Returns: skrf . network . Network \u2013 The data for the requested polarization load classmethod \u00b6 load ( path ) Loads a calibration from a file. Parameters: path ( str | Path ) \u2013 The file to load Returns: Calibration \u2013 A new calibration containing the data from the file save \u00b6 save ( path ) Save this calibration to a file. Parameters: path ( str | Path ) \u2013 Where to save the file","title":"calibration"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration","text":"Calibration ( networks , notes = None ) A class containing data for a scalar substitution calibration. This kind of calibration is performed when you have an antenna with known performance. By measuring the antenna with your experiment setup, you can determine the difference between the expected performance and what you measure influenced by path loss, cable loss, etc. Additionally, notes can be stored with the calibration which can describe important contextual information about the setup as it existed when this calibration was created. When saved, this class is stored as a .mdif file, a text-based file format. Comments are stored using a specific delimiter ('@') to allow them to be differentiated from other comments in the file. To make it easier to differentiate calibrations from other data files, it is suggested to use the file extension .pycal Parameters: networks ( list [ skrf . Network ] | skrf . NetworkSet ) \u2013 The networks containing the calibration data notes ( list [ str ] | None ) \u2013 A list of strings containing notes. Each element is another line.","title":"Calibration"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.frequency","text":"frequency : skrf . Frequency The frequency range covered by this calibration","title":"frequency"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.networks","text":"networks : skrf . NetworkSet The underlying networks that comprise this calibration","title":"networks"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.polarizations","text":"polarizations : list [ str ] The names of the polarizations in this calibration.","title":"polarizations"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.get_polarization","text":"get_polarization ( polarization ) Get the Network for the named polarization. Parameters: polarization ( str ) \u2013 The name of the polarization Returns: skrf . network . Network \u2013 The data for the requested polarization","title":"get_polarization()"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.load","text":"load ( path ) Loads a calibration from a file. Parameters: path ( str | Path ) \u2013 The file to load Returns: Calibration \u2013 A new calibration containing the data from the file","title":"load()"},{"location":"reference/pychamber/calibration/#pychamber.calibration.Calibration.save","text":"save ( path ) Save this calibration to a file. Parameters: path ( str | Path ) \u2013 Where to save the file","title":"save()"},{"location":"reference/pychamber/experiment/","text":"Experiment \u00b6 Experiment ( analyzer , positioner , thetas , phis , polarizations , frequency , ) An abstraction class that simplifies running experiments from scripts. The Experiment class is effectively a wrapper around a function that performs a single measurement. This class should only be used during scripting. In the GUI, it's related class, ExperimentWorker is used, which does various thread / Qt related things. Parameters: analyzer ( skrf . vi . vna . VNA ) \u2013 Network Analyzer positioner ( Positioner ) \u2013 Positioner instance thetas ( np . ndarray ) \u2013 Array of theta locations (in degrees) phis ( np . ndarray ) \u2013 Array of phi locations (in degrees) polarizations ( list [ tuple [ str , int , int ]] ) \u2013 List of (name, a, b), where a, b are port numbers representing which S parameters correspond to the polarization. run \u00b6 run () Run the experiment. Runs the experiment as defined. This command will display status information using the rich library. Returns: ExperimentResult ( ExperimentResult ) \u2013 Measured data from the experiment","title":"experiment"},{"location":"reference/pychamber/experiment/#pychamber.experiment.Experiment","text":"Experiment ( analyzer , positioner , thetas , phis , polarizations , frequency , ) An abstraction class that simplifies running experiments from scripts. The Experiment class is effectively a wrapper around a function that performs a single measurement. This class should only be used during scripting. In the GUI, it's related class, ExperimentWorker is used, which does various thread / Qt related things. Parameters: analyzer ( skrf . vi . vna . VNA ) \u2013 Network Analyzer positioner ( Positioner ) \u2013 Positioner instance thetas ( np . ndarray ) \u2013 Array of theta locations (in degrees) phis ( np . ndarray ) \u2013 Array of phi locations (in degrees) polarizations ( list [ tuple [ str , int , int ]] ) \u2013 List of (name, a, b), where a, b are port numbers representing which S parameters correspond to the polarization.","title":"Experiment"},{"location":"reference/pychamber/experiment/#pychamber.experiment.Experiment.run","text":"run () Run the experiment. Runs the experiment as defined. This command will display status information using the rich library. Returns: ExperimentResult ( ExperimentResult ) \u2013 Measured data from the experiment","title":"run()"},{"location":"reference/pychamber/experiment_result/","text":"ExperimentResult \u00b6 ExperimentResult ( thetas , phis , polarizations , frequency , parent = None ) Bases: QObject Results from an experiment. This class contains the data from running an experiment. It can be appended to, have calibrations applied to it, and provides methods to get particular subsets of the data like particular cuts or data from a particular frequency. Attributes: dataAppended ( PySide6 . QtCore . Signal ) \u2013 PyQt signal emitted when a data append operation has completed Parameters: thetas ( np . ndarray ) \u2013 Array of theta locations (in degrees) phis ( np . ndarray ) \u2013 Array of phi locations (in degrees) polarizations ( list [ str ] ) \u2013 List of (name, a, b), where a, b are port numbers representing which S parameters correspond to the polarization. frequency ( skrf . frequency . Frequency ) \u2013 The frequency range of this measurement calibrated_data property \u00b6 calibrated_data : skrf . NetworkSet The subset of this result that has been calibrated created property \u00b6 created : str The time this result object was created f property \u00b6 f : np . ndarray An array of all frequency points in this result frequency property \u00b6 frequency : skrf . Frequency The frequency range of this result. has_calibrated_data property \u00b6 has_calibrated_data : bool Whether or not this result contains calibrated data params property \u00b6 params : list | None The parameter names in this result phis property \u00b6 phis : np . ndarray A list of phis in this result polarizations property \u00b6 polarizations : list [ str ] A list of polarizations in this result raw_data property \u00b6 raw_data : skrf . NetworkSet The subset of this result that has not been calibrated thetas property \u00b6 thetas : np . ndarray A list of thetas in this result uuid property \u00b6 uuid : str This result's unique identifier. append \u00b6 append ( ntwk , calibration = None ) Append a data point to the result. This command locks the internal QReadWriteLock, which really only matters when running in a QApplication. Parameters: ntwk ( skrf . network . Network ) \u2013 The data to append calibration ( Calibration | None ) \u2013 If a calibration is passed, the raw data and the data after applying the calibration will be appended to the result apply_calibration \u00b6 apply_calibration ( calibration ) Applies a calibration to this result. This method applies the calibration to this result and appends the calibrated data. In other words, after this method, the result will contain both raw and calibrated data. Parameters: calibration ( Calibration ) \u2013 The calibration to apply to this result Raises: ValueError \u2013 Raised if the calibration does not contain data for any of the polarizations in this result get_3d_data \u00b6 get_3d_data ( polarization , frequency , calibrated = False ) Get a subset of data for all thetas and phis at the specified frequency. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A 2D numpy array of the requested data get_over_freq_vals \u00b6 get_over_freq_vals ( polarization , theta , phi , calibrated = False ) Get a subset of data for all frequencies at the specified theta and phi. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for theta ( float ) \u2013 The theta value you want a phi cut for phi ( float ) \u2013 The phi value you want a theta cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data get_phi_cut \u00b6 get_phi_cut ( polarization , frequency , theta , calibrated = False ) Get a subset of data for all phis and a specific theta. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for theta ( float ) \u2013 The theta value you want a phi cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data get_theta_cut \u00b6 get_theta_cut ( polarization , frequency , phi , calibrated = False ) Get a subset of data for all thetas and a specific phi. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for phi ( float ) \u2013 The phi value you want a theta cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data get_unique_param_vals \u00b6 get_unique_param_vals ( param ) Get a list of unique values for the specified parameter. This is mostly useful internally, but as an example, consider a result with 4 data points (skrf.Network) with the following params: [ { 'theta': 0, 'phi': 0, 'polarization': 'Vertical', 'calibrated': False, }, { 'theta': 0, 'phi': 0, 'polarization': 'Horizontal', 'calibrated': False, }, { 'theta': 0, 'phi': 5, 'polarization': 'Vertical', 'calibrated': False, }, { 'theta': 0, 'phi': 5, 'polarization': 'Horizontal', 'calibrated': False, }, ] calling get_unique_param_vals('phi') would return [0, 5] Parameters: param ( str ) \u2013 The parameter of interest. Returns: list [ Any ] \u2013 list[Any]: List of unique values associated with the specified parameter. load classmethod \u00b6 load ( path ) Load an experiment result from a file. This loads an .mdif file and attempts to construct an ExperimentResult from it. Parameters: path ( str | pathlib . Path ) \u2013 path to file Returns: ExperimentResult ( ExperimentResult ) \u2013 The loaded data Raises: InvalidFileError \u2013 When the file is not a valid PyChamber results file save \u00b6 save ( path ) Save the result to a file. Saves this result to a .mdif file. This is a text-based file format. Parameters: path ( str | pathlib . Path ) \u2013 The file to save the results to InvalidFileError \u00b6 Bases: Exception Exception raised when an attempt to load a result file fails. If a valid .mdif file was passed, this error was likely the result of the file not containing all the requisite data (thetas, phis, etc).","title":"experiment_result"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult","text":"ExperimentResult ( thetas , phis , polarizations , frequency , parent = None ) Bases: QObject Results from an experiment. This class contains the data from running an experiment. It can be appended to, have calibrations applied to it, and provides methods to get particular subsets of the data like particular cuts or data from a particular frequency. Attributes: dataAppended ( PySide6 . QtCore . Signal ) \u2013 PyQt signal emitted when a data append operation has completed Parameters: thetas ( np . ndarray ) \u2013 Array of theta locations (in degrees) phis ( np . ndarray ) \u2013 Array of phi locations (in degrees) polarizations ( list [ str ] ) \u2013 List of (name, a, b), where a, b are port numbers representing which S parameters correspond to the polarization. frequency ( skrf . frequency . Frequency ) \u2013 The frequency range of this measurement","title":"ExperimentResult"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.calibrated_data","text":"calibrated_data : skrf . NetworkSet The subset of this result that has been calibrated","title":"calibrated_data"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.created","text":"created : str The time this result object was created","title":"created"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.f","text":"f : np . ndarray An array of all frequency points in this result","title":"f"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.frequency","text":"frequency : skrf . Frequency The frequency range of this result.","title":"frequency"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.has_calibrated_data","text":"has_calibrated_data : bool Whether or not this result contains calibrated data","title":"has_calibrated_data"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.params","text":"params : list | None The parameter names in this result","title":"params"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.phis","text":"phis : np . ndarray A list of phis in this result","title":"phis"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.polarizations","text":"polarizations : list [ str ] A list of polarizations in this result","title":"polarizations"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.raw_data","text":"raw_data : skrf . NetworkSet The subset of this result that has not been calibrated","title":"raw_data"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.thetas","text":"thetas : np . ndarray A list of thetas in this result","title":"thetas"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.uuid","text":"uuid : str This result's unique identifier.","title":"uuid"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.append","text":"append ( ntwk , calibration = None ) Append a data point to the result. This command locks the internal QReadWriteLock, which really only matters when running in a QApplication. Parameters: ntwk ( skrf . network . Network ) \u2013 The data to append calibration ( Calibration | None ) \u2013 If a calibration is passed, the raw data and the data after applying the calibration will be appended to the result","title":"append()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.apply_calibration","text":"apply_calibration ( calibration ) Applies a calibration to this result. This method applies the calibration to this result and appends the calibrated data. In other words, after this method, the result will contain both raw and calibrated data. Parameters: calibration ( Calibration ) \u2013 The calibration to apply to this result Raises: ValueError \u2013 Raised if the calibration does not contain data for any of the polarizations in this result","title":"apply_calibration()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.get_3d_data","text":"get_3d_data ( polarization , frequency , calibrated = False ) Get a subset of data for all thetas and phis at the specified frequency. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A 2D numpy array of the requested data","title":"get_3d_data()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.get_over_freq_vals","text":"get_over_freq_vals ( polarization , theta , phi , calibrated = False ) Get a subset of data for all frequencies at the specified theta and phi. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for theta ( float ) \u2013 The theta value you want a phi cut for phi ( float ) \u2013 The phi value you want a theta cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data","title":"get_over_freq_vals()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.get_phi_cut","text":"get_phi_cut ( polarization , frequency , theta , calibrated = False ) Get a subset of data for all phis and a specific theta. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for theta ( float ) \u2013 The theta value you want a phi cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data","title":"get_phi_cut()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.get_theta_cut","text":"get_theta_cut ( polarization , frequency , phi , calibrated = False ) Get a subset of data for all thetas and a specific phi. Parameters: polarization ( str ) \u2013 The name of the polarization you want data for frequency ( float ) \u2013 What frequency you want data for phi ( float ) \u2013 The phi value you want a theta cut for calibrated ( bool ) \u2013 Pass True to request calibrated data Returns: np . ndarray \u2013 A numpy array of the requested data","title":"get_theta_cut()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.get_unique_param_vals","text":"get_unique_param_vals ( param ) Get a list of unique values for the specified parameter. This is mostly useful internally, but as an example, consider a result with 4 data points (skrf.Network) with the following params: [ { 'theta': 0, 'phi': 0, 'polarization': 'Vertical', 'calibrated': False, }, { 'theta': 0, 'phi': 0, 'polarization': 'Horizontal', 'calibrated': False, }, { 'theta': 0, 'phi': 5, 'polarization': 'Vertical', 'calibrated': False, }, { 'theta': 0, 'phi': 5, 'polarization': 'Horizontal', 'calibrated': False, }, ] calling get_unique_param_vals('phi') would return [0, 5] Parameters: param ( str ) \u2013 The parameter of interest. Returns: list [ Any ] \u2013 list[Any]: List of unique values associated with the specified parameter.","title":"get_unique_param_vals()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.load","text":"load ( path ) Load an experiment result from a file. This loads an .mdif file and attempts to construct an ExperimentResult from it. Parameters: path ( str | pathlib . Path ) \u2013 path to file Returns: ExperimentResult ( ExperimentResult ) \u2013 The loaded data Raises: InvalidFileError \u2013 When the file is not a valid PyChamber results file","title":"load()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.ExperimentResult.save","text":"save ( path ) Save the result to a file. Saves this result to a .mdif file. This is a text-based file format. Parameters: path ( str | pathlib . Path ) \u2013 The file to save the results to","title":"save()"},{"location":"reference/pychamber/experiment_result/#pychamber.experiment_result.InvalidFileError","text":"Bases: Exception Exception raised when an attempt to load a result file fails. If a valid .mdif file was passed, this error was likely the result of the file not containing all the requisite data (thetas, phis, etc).","title":"InvalidFileError"},{"location":"reference/pychamber/math_fns/","text":"cartesian_to_spherical \u00b6 cartesian_to_spherical ( x , y , z ) Convert cartesian coordinates to spherical coordinates. Parameters: x ( np . ndarray ) \u2013 x coordinates y ( np . ndarray ) \u2013 y coordinates z ( np . ndarray ) \u2013 z coordinates Returns: r ( np . ndarray ) \u2013 r coordinates theta ( np . ndarray ) \u2013 theta coordinates phi ( np . ndarray ) \u2013 phi coordinates clean_complex_to_db \u00b6 clean_complex_to_db ( array ) Calculates dB from an array of complex values. Does some preprocessing of the input data to ensure no warnings are generated. Specifically, it replaces 0 magnitudes with a very small constant (1e-20). Parameters: array ( np . ndarray ) \u2013 Array of complex values Returns: np . ndarray \u2013 \\(20 log_{10}(array)\\) spherical_to_cartesian \u00b6 spherical_to_cartesian ( r , theta , phi ) Convert spherical coordinates to cartesian coordinates. Parameters: r ( np . ndarray ) \u2013 r coordinates theta ( np . ndarray ) \u2013 theta coordinates phi ( np . ndarray ) \u2013 phi coordinates Returns: x ( np . ndarray ) \u2013 x coordinates y ( np . ndarray ) \u2013 y coordinates z ( np . ndarray ) \u2013 z coordinates","title":"math_fns"},{"location":"reference/pychamber/math_fns/#pychamber.math_fns.cartesian_to_spherical","text":"cartesian_to_spherical ( x , y , z ) Convert cartesian coordinates to spherical coordinates. Parameters: x ( np . ndarray ) \u2013 x coordinates y ( np . ndarray ) \u2013 y coordinates z ( np . ndarray ) \u2013 z coordinates Returns: r ( np . ndarray ) \u2013 r coordinates theta ( np . ndarray ) \u2013 theta coordinates phi ( np . ndarray ) \u2013 phi coordinates","title":"cartesian_to_spherical()"},{"location":"reference/pychamber/math_fns/#pychamber.math_fns.clean_complex_to_db","text":"clean_complex_to_db ( array ) Calculates dB from an array of complex values. Does some preprocessing of the input data to ensure no warnings are generated. Specifically, it replaces 0 magnitudes with a very small constant (1e-20). Parameters: array ( np . ndarray ) \u2013 Array of complex values Returns: np . ndarray \u2013 \\(20 log_{10}(array)\\)","title":"clean_complex_to_db()"},{"location":"reference/pychamber/math_fns/#pychamber.math_fns.spherical_to_cartesian","text":"spherical_to_cartesian ( r , theta , phi ) Convert spherical coordinates to cartesian coordinates. Parameters: r ( np . ndarray ) \u2013 r coordinates theta ( np . ndarray ) \u2013 theta coordinates phi ( np . ndarray ) \u2013 phi coordinates Returns: x ( np . ndarray ) \u2013 x coordinates y ( np . ndarray ) \u2013 y coordinates z ( np . ndarray ) \u2013 z coordinates","title":"spherical_to_cartesian()"},{"location":"reference/pychamber/settings/","text":"SettingsManager \u00b6 SettingsManager ( parent = None ) Bases: QObject Persistent settings manager. This class uses Qt's QSettings class which abstracts platform-specific locations for persistent settings. For example, on Windows this is the registry, and on Linux it's typically ~/.config/ . Beyond maintaining settings, the GUI can also register widgets with particular settings so that they may be saved to a setting when changed, and updated from stored settings when the application is loaded. You should NOT need to instantiate a SettingsManager yourself. Instead, you should opt to import and use the global CONF object like from pychamber.settings import CONF Attributes: settingsChanged ( PySide6 . QtCore . Signal ) \u2013 Signal emitted when settings are changed widget_fns ( dict ) \u2013 Dictionary of QWidget names, and their getter/setter methods. This is used when updating widgets with existing settings or when updating settings from widgets. __getitem__ \u00b6 __getitem__ ( key ) Tries to retrive the value specified by key. If the setting has been registered, it will be cast to the appropriate type before being returned Parameters: key ( str ) \u2013 The setting name Returns: Any \u2013 The value associated with the key __setitem__ \u00b6 __setitem__ ( key , value ) Changes the setting to the specified value register_widgets \u00b6 register_widgets ( widget_map ) Registers widgets with the settings object. When creating widgets with values you want to be persistent, you can register them by creating a widget map and calling this function. The widget_map should be of the form: widget_map = { \"<key>\" : ( < widget > , < default value > , < type > ), } Parameters: widget_map ( dict ) \u2013 A dictionary of the type described update_widgets_from_settings \u00b6 update_widgets_from_settings () Updates registered widgets from the stored settings.","title":"settings"},{"location":"reference/pychamber/settings/#pychamber.settings.SettingsManager","text":"SettingsManager ( parent = None ) Bases: QObject Persistent settings manager. This class uses Qt's QSettings class which abstracts platform-specific locations for persistent settings. For example, on Windows this is the registry, and on Linux it's typically ~/.config/ . Beyond maintaining settings, the GUI can also register widgets with particular settings so that they may be saved to a setting when changed, and updated from stored settings when the application is loaded. You should NOT need to instantiate a SettingsManager yourself. Instead, you should opt to import and use the global CONF object like from pychamber.settings import CONF Attributes: settingsChanged ( PySide6 . QtCore . Signal ) \u2013 Signal emitted when settings are changed widget_fns ( dict ) \u2013 Dictionary of QWidget names, and their getter/setter methods. This is used when updating widgets with existing settings or when updating settings from widgets.","title":"SettingsManager"},{"location":"reference/pychamber/settings/#pychamber.settings.SettingsManager.__getitem__","text":"__getitem__ ( key ) Tries to retrive the value specified by key. If the setting has been registered, it will be cast to the appropriate type before being returned Parameters: key ( str ) \u2013 The setting name Returns: Any \u2013 The value associated with the key","title":"__getitem__()"},{"location":"reference/pychamber/settings/#pychamber.settings.SettingsManager.__setitem__","text":"__setitem__ ( key , value ) Changes the setting to the specified value","title":"__setitem__()"},{"location":"reference/pychamber/settings/#pychamber.settings.SettingsManager.register_widgets","text":"register_widgets ( widget_map ) Registers widgets with the settings object. When creating widgets with values you want to be persistent, you can register them by creating a widget map and calling this function. The widget_map should be of the form: widget_map = { \"<key>\" : ( < widget > , < default value > , < type > ), } Parameters: widget_map ( dict ) \u2013 A dictionary of the type described","title":"register_widgets()"},{"location":"reference/pychamber/settings/#pychamber.settings.SettingsManager.update_widgets_from_settings","text":"update_widgets_from_settings () Updates registered widgets from the stored settings.","title":"update_widgets_from_settings()"},{"location":"reference/pychamber/positioner/","text":"","title":"positioner"},{"location":"reference/pychamber/positioner/factory/","text":"","title":"factory"},{"location":"reference/pychamber/positioner/interface/","text":"","title":"interface"}]}