{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyChamber \u00b6 PyChamber is an open-source application written with Qt to take anechoic chamber measurements. All measurements are saved as scikit-rf objects (or classes derived from them) which greatly simplifies post-processing. Table of Contents \u00b6 Overview : This page Usage : How to use the program API Reference : Documentation of the Python API Installation : Ways to install PyChamber Contributing : How to help with the development of PyChamber Changelog : Summaries of each update of PyChamber","title":"Overview"},{"location":"#pychamber","text":"PyChamber is an open-source application written with Qt to take anechoic chamber measurements. All measurements are saved as scikit-rf objects (or classes derived from them) which greatly simplifies post-processing.","title":"PyChamber"},{"location":"#table-of-contents","text":"Overview : This page Usage : How to use the program API Reference : Documentation of the Python API Installation : Ways to install PyChamber Contributing : How to help with the development of PyChamber Changelog : Summaries of each update of PyChamber","title":"Table of Contents"},{"location":"SUMMARY/","text":"Overview Usage API Reference Installation Contributing Changelog","title":"SUMMARY"},{"location":"changelog/","text":"{% include-markdown \"../CHANGELOG.md\" %}","title":"Changelog"},{"location":"contributing/","text":"{% include-markdown \"../CONTRIBUTING.md\" %}","title":"Contributing"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 Todo! From source \u00b6 The source for PyChamber can be downloaded from the Github repo . You can either clone the public repository: git clone git://github.com/hrg-lab/pychamber Or download the tarball: curl -OJL https://github.com/hrg-lab/pychamber/tarball/master Once you have a copy of the source, you can install it with: pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"Todo!","title":"Stable release"},{"location":"installation/#from-source","text":"The source for PyChamber can be downloaded from the Github repo . You can either clone the public repository: git clone git://github.com/hrg-lab/pychamber Or download the tarball: curl -OJL https://github.com/hrg-lab/pychamber/tarball/master Once you have a copy of the source, you can install it with: pip install .","title":"From source"},{"location":"usage/","text":"Main Window \u00b6 Above is a screenshot of the main window of PyChamber. Each GUI element is grouped by function. For example, the \"Analyzer\" box is where all interactions with the network analyzer take place. The analyzer and positioner boxes will not allow you to interact with them until you've established a connection to the analyzer / positioner. The experiment box will not be enabled until you connect to both the analyzer and a positioner. Analyzer \u00b6 The analyzer box is where you will connect to the analyzer, assign polarizations to specific S-parameters, and assign your frequency settings. Any more complex settings will have to be done on the analyzer, e.g. IF bandwidth, port power settings, etc. The \"Model\" dropdown is populated with the models supported by scikit-rf's VI module. If you don't see your analyzer listed, consider contributing to scikit-rf with an implementation! The \"Address\" dropdown allows you to select the VISA address where your instrument is located. If you do not see your instrument's address, you may not have the correct VISA installation installed or you need to select the proper VISA library that supports your instrument (more detail below). Clicking \"Connect\" will attempt to connect to the analyzer and if successful, populate the box with the current analyzer frequency settings. Polarization \u00b6 You can assign specific S-parameters to specific polarizations. The labels are provided for convenience and are what each measurement will be labeled in the final dataset. The labels can be anything you choose. The dropdown box is where you assign a specific measurement to each polarization. For example, if your vertical polarization is S21 and your horizontal polarization is S41, you would choose S21 and S41 in each dropdown appropriately. The available S-paramenters are dependent on your specific analyzer. Frequency \u00b6 Here you can change the frequency settings of your analyzer. You can enter frequencies as you would imagine, e.g. \"650 MHz\", \"10GHz\", \"10000000\", etc. !!! warning Important! You must press enter to finalize changes and apply them to your analyzer. Calibration \u00b6 TODO :) Positioner \u00b6 This is where you choose your positioner model, connect to positioners, set the range and step size for your experiments, jog the positioner, etc. Currently, the only positioner supported is the Diamond Engineering D6050. Please consider contributing to support more positioners! The port dropdown is the USB port the positioner is connected to. Unlike the analyzer, the positioner does not store information about it's location internally. This means if you quit the program you'll have to redefine the 0,0 position. Once connected, you can jog the positioner using the appropriate buttons. The 0 buttons will return the positioner to its defined 0 position. The step size defines how much the positioner will move with each button press, and the \"Jog To\" field allows you to jog the positioner to a specific location. !!! warning Important! You must press the check button to jog. This is intentional to prevent the accidental movement of the positioner. Defining the origin \u00b6 To define the 0,0 point of the positioner, you must jog it to the position you want to define as the origin (typically boresight). Then click \"Set 0,0\" in the bottom left. Running an Experiment \u00b6 After you've connected to the analyzer and positioner, set up your frequency settings, set up your positioner settings, and any other set up you need, running an experiment is as simple as clicking the appropriate button. This will move the positioner to the minimum azimuth and elevation and begin taking measurements. The time remaining is simply an estimate based on the time each move and measure has taken. Clicking \"ABORT\" will attempt to stop the positioner but will only abort after a movement is completed. Results \u00b6 The \"Polar Plot\" and \"Over Frequency Plot\" are updated as measurements are taken, and you can view different data as it's being taken. Similarly to the analyzer frequency, the polar plot frequency can be entered as you would expect, e.g. \"450 MHz\", \"2.45GHz\", etc. Once measurements have started, the polarization drop downs will be populated with the labels you specified. Menus \u00b6 File menu \u00b6 \"Save\" and \"Load\" do what you would expect. Loading the data will update the polar and over frequency plots to allow to you explore the data. \"Settings\" will bring up the settings window where you can change which VISA implementation is used to communicate with the analyzer, and the Python Console Theme is simply the color scheme of the integrated Python console. Tools \u00b6 The \"Tools\" menu contains helpful utilites, currently only an integrated Python console. If an experiment has been run or data loaded, it will be available in the console as the variable measurements . The Python console is provided to allow the user to perform mathematical manipulation of the data. More tools will likely be added as PyChamber matures. Help \u00b6 Here you can see information about PyChamber, submit a bug report or view / save the program logs which can be helpful when submitting a bug report.","title":"Usage"},{"location":"usage/#main-window","text":"Above is a screenshot of the main window of PyChamber. Each GUI element is grouped by function. For example, the \"Analyzer\" box is where all interactions with the network analyzer take place. The analyzer and positioner boxes will not allow you to interact with them until you've established a connection to the analyzer / positioner. The experiment box will not be enabled until you connect to both the analyzer and a positioner.","title":"Main Window"},{"location":"usage/#analyzer","text":"The analyzer box is where you will connect to the analyzer, assign polarizations to specific S-parameters, and assign your frequency settings. Any more complex settings will have to be done on the analyzer, e.g. IF bandwidth, port power settings, etc. The \"Model\" dropdown is populated with the models supported by scikit-rf's VI module. If you don't see your analyzer listed, consider contributing to scikit-rf with an implementation! The \"Address\" dropdown allows you to select the VISA address where your instrument is located. If you do not see your instrument's address, you may not have the correct VISA installation installed or you need to select the proper VISA library that supports your instrument (more detail below). Clicking \"Connect\" will attempt to connect to the analyzer and if successful, populate the box with the current analyzer frequency settings.","title":"Analyzer"},{"location":"usage/#polarization","text":"You can assign specific S-parameters to specific polarizations. The labels are provided for convenience and are what each measurement will be labeled in the final dataset. The labels can be anything you choose. The dropdown box is where you assign a specific measurement to each polarization. For example, if your vertical polarization is S21 and your horizontal polarization is S41, you would choose S21 and S41 in each dropdown appropriately. The available S-paramenters are dependent on your specific analyzer.","title":"Polarization"},{"location":"usage/#frequency","text":"Here you can change the frequency settings of your analyzer. You can enter frequencies as you would imagine, e.g. \"650 MHz\", \"10GHz\", \"10000000\", etc. !!! warning Important! You must press enter to finalize changes and apply them to your analyzer.","title":"Frequency"},{"location":"usage/#calibration","text":"TODO :)","title":"Calibration"},{"location":"usage/#positioner","text":"This is where you choose your positioner model, connect to positioners, set the range and step size for your experiments, jog the positioner, etc. Currently, the only positioner supported is the Diamond Engineering D6050. Please consider contributing to support more positioners! The port dropdown is the USB port the positioner is connected to. Unlike the analyzer, the positioner does not store information about it's location internally. This means if you quit the program you'll have to redefine the 0,0 position. Once connected, you can jog the positioner using the appropriate buttons. The 0 buttons will return the positioner to its defined 0 position. The step size defines how much the positioner will move with each button press, and the \"Jog To\" field allows you to jog the positioner to a specific location. !!! warning Important! You must press the check button to jog. This is intentional to prevent the accidental movement of the positioner.","title":"Positioner"},{"location":"usage/#defining-the-origin","text":"To define the 0,0 point of the positioner, you must jog it to the position you want to define as the origin (typically boresight). Then click \"Set 0,0\" in the bottom left.","title":"Defining the origin"},{"location":"usage/#running-an-experiment","text":"After you've connected to the analyzer and positioner, set up your frequency settings, set up your positioner settings, and any other set up you need, running an experiment is as simple as clicking the appropriate button. This will move the positioner to the minimum azimuth and elevation and begin taking measurements. The time remaining is simply an estimate based on the time each move and measure has taken. Clicking \"ABORT\" will attempt to stop the positioner but will only abort after a movement is completed.","title":"Running an Experiment"},{"location":"usage/#results","text":"The \"Polar Plot\" and \"Over Frequency Plot\" are updated as measurements are taken, and you can view different data as it's being taken. Similarly to the analyzer frequency, the polar plot frequency can be entered as you would expect, e.g. \"450 MHz\", \"2.45GHz\", etc. Once measurements have started, the polarization drop downs will be populated with the labels you specified.","title":"Results"},{"location":"usage/#menus","text":"","title":"Menus"},{"location":"usage/#file-menu","text":"\"Save\" and \"Load\" do what you would expect. Loading the data will update the polar and over frequency plots to allow to you explore the data. \"Settings\" will bring up the settings window where you can change which VISA implementation is used to communicate with the analyzer, and the Python Console Theme is simply the color scheme of the integrated Python console.","title":"File menu"},{"location":"usage/#tools","text":"The \"Tools\" menu contains helpful utilites, currently only an integrated Python console. If an experiment has been run or data loaded, it will be available in the console as the variable measurements . The Python console is provided to allow the user to perform mathematical manipulation of the data. More tools will likely be added as PyChamber matures.","title":"Tools"},{"location":"usage/#help","text":"Here you can see information about PyChamber, submit a bug report or view / save the program logs which can be helpful when submitting a bug report.","title":"Help"},{"location":"reference/","text":"API Reference \u00b6 PyChamber includes an API that allows easier scripting. This pages summarizes that API and provides some helpful examples. The goal is to eventually provide functions to allow the user to script measurements entirely. This would allow users to make adjustments external to the operation of the chamber like changing weights in a phased array without having to continuously enter the chamber or switch back and forth between programs. PyChamber is deeply integrated with scikit-rf. Information about scikit-rf objects should be found in their documentation Measurement Results \u00b6 When a measurement is taken, it is tagged with the corresponding label (user provided but \"Polarization 1\" or \"Polarization 2\" by default) and stored in a dictionary of NetworkModels. NetworkModels are simply extensions of scikit-rf's NetworkSet that provides helpful functions that are relevant to chamber measurements. Roughly: { \"Polarization 1\" : NetworkModel , \"Polarization 2\" : NetworkModel , } which is what the object that will be returned when loading measurements from a previous experiment. Loading Measurements \u00b6 Loading measurements is as simple as importing pychamber and calling load . import pychamber data = pychamber . load ( \"path/to/data\" )","title":"API Reference"},{"location":"reference/#api-reference","text":"PyChamber includes an API that allows easier scripting. This pages summarizes that API and provides some helpful examples. The goal is to eventually provide functions to allow the user to script measurements entirely. This would allow users to make adjustments external to the operation of the chamber like changing weights in a phased array without having to continuously enter the chamber or switch back and forth between programs. PyChamber is deeply integrated with scikit-rf. Information about scikit-rf objects should be found in their documentation","title":"API Reference"},{"location":"reference/#measurement-results","text":"When a measurement is taken, it is tagged with the corresponding label (user provided but \"Polarization 1\" or \"Polarization 2\" by default) and stored in a dictionary of NetworkModels. NetworkModels are simply extensions of scikit-rf's NetworkSet that provides helpful functions that are relevant to chamber measurements. Roughly: { \"Polarization 1\" : NetworkModel , \"Polarization 2\" : NetworkModel , } which is what the object that will be returned when loading measurements from a previous experiment.","title":"Measurement Results"},{"location":"reference/#loading-measurements","text":"Loading measurements is as simple as importing pychamber and calling load . import pychamber data = pychamber . load ( \"path/to/data\" )","title":"Loading Measurements"},{"location":"reference/api/","text":"Defines the general PyChamber api. Provides helpful methods not found elsewhere in PyChamber. Specifically: load to load data from previous experiments. load ( path ) \u00b6 Loads data from previous experiments. Parameters: Name Type Description Default path Union [ str , PathLike ] path to data file required Returns: Type Description Dict [ str , NetworkModel ] The dictionary of previous experiment data Source code in pychamber/lib.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def load ( path : Union [ str , PathLike ]) -> Dict [ str , NetworkModel ]: \"\"\"Loads data from previous experiments. Args: path: path to data file Returns: - The dictionary of previous experiment data \"\"\" with open ( path , \"rb\" ) as ff : data = pickle . load ( ff ) return data","title":"Api"},{"location":"reference/api/#pychamber.lib.load","text":"Loads data from previous experiments. Parameters: Name Type Description Default path Union [ str , PathLike ] path to data file required Returns: Type Description Dict [ str , NetworkModel ] The dictionary of previous experiment data Source code in pychamber/lib.py 17 18 19 20 21 22 23 24 25 26 27 28 29 def load ( path : Union [ str , PathLike ]) -> Dict [ str , NetworkModel ]: \"\"\"Loads data from previous experiments. Args: path: path to data file Returns: - The dictionary of previous experiment data \"\"\" with open ( path , \"rb\" ) as ff : data = pickle . load ( ff ) return data","title":"load()"},{"location":"reference/network_model/","text":"An extension of scikit-rf's NetworkSet. This module defines the NetworkModel class which extends scikit-rf's NetworkSet to provide helpful functions relevant to chamber measurements. When taking measurements, each polarization will be a NetworkModel. NetworkModel \u00b6 Bases: NetworkSet Set of Networks that represent one meausurement. Extends scikit-rf's NetworkSet to provide helper functions relevant to chamber measurements. Attributes: Name Type Description freqs np . ndarray List of frequencies in the set azimuths np . ndarray List of azimuths in the set elevations np . ndarray List of elevations in the set Source code in pychamber/classes/network_model.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class NetworkModel ( NetworkSet ): \"\"\"Set of Networks that represent one meausurement. Extends scikit-rf's NetworkSet to provide helper functions relevant to chamber measurements. Attributes: freqs: List of frequencies in the set azimuths: List of azimuths in the set elevations: List of elevations in the set \"\"\" @property def freqs ( self ) -> np . ndarray : \"\"\"The list of frequencies contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return self [ 0 ] . frequency . f # type: ignore @property def azimuths ( self ) -> np . ndarray : \"\"\"The list of azimuths contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'azimuth' ] for n in self . sel ({ 'elevation' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) @property def elevations ( self ) -> np . ndarray : \"\"\"The list of elevations contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'elevation' ] for n in self . sel ({ 'azimuth' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) def __str__ ( self ) -> str : if len ( self ) == 0 : return \"Empty NetworkModel\" else : return ( f \"NetworkModel(Frequency: { self [ 0 ] . frequency } ,\" # type: ignore f \"Azimuths: { len ( self . azimuths ) } points,\" f \"Elevations: { len ( self . elevations ) } points)\" ) def mags ( self , freq : Optional [ str ] = None , azimuth : Optional [ float ] = None , elevation : Optional [ float ] = None , ) -> np . ndarray : \"\"\"Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: ```py import pychamber data = pychamber.load(\"/path/to/data\") # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data[\"Vertical\"] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert.mags(freq=\"2.45 GHz\", elevation=0) ``` This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Args: freq: Frequency of interest azimuth: Azimuth of interest elevation: Elevation of interest \"\"\" log . debug ( \"Fetching Mags\" ) if len ( self ) == 0 : return np . array ([]) else : params = dict () if azimuth is not None : params [ 'azimuth' ] = azimuth if elevation is not None : params [ 'elevation' ] = elevation log . debug ( f \" { params =} \" ) if freq : return np . array ([ n [ freq ] . s_db for n in self . sel ( params )]) . reshape ( - 1 , 1 ) # type: ignore else : return self . sel ( params )[ 0 ] . s_db . reshape ( - 1 , 1 ) # type: ignore def append ( self , ntwk : Network ) -> NetworkModel : log . debug ( \"Appending to network model\" ) ret = NetworkModel ( list ( self ) + [ ntwk ]) # type: ignore log . debug ( f \" { ret =} \" ) return ret azimuths () property \u00b6 The list of azimuths contained in the set. Source code in pychamber/classes/network_model.py 39 40 41 42 43 44 45 46 47 @property def azimuths ( self ) -> np . ndarray : \"\"\"The list of azimuths contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'azimuth' ] for n in self . sel ({ 'elevation' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) elevations () property \u00b6 The list of elevations contained in the set. Source code in pychamber/classes/network_model.py 49 50 51 52 53 54 55 56 57 @property def elevations ( self ) -> np . ndarray : \"\"\"The list of elevations contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'elevation' ] for n in self . sel ({ 'azimuth' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) freqs () property \u00b6 The list of frequencies contained in the set. Source code in pychamber/classes/network_model.py 31 32 33 34 35 36 37 @property def freqs ( self ) -> np . ndarray : \"\"\"The list of frequencies contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return self [ 0 ] . frequency . f # type: ignore mags ( freq = None , azimuth = None , elevation = None ) \u00b6 Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: import pychamber data = pychamber . load ( \"/path/to/data\" ) # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data [ \"Vertical\" ] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert . mags ( freq = \"2.45 GHz\" , elevation = 0 ) This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Parameters: Name Type Description Default freq Optional [ str ] Frequency of interest None azimuth Optional [ float ] Azimuth of interest None elevation Optional [ float ] Elevation of interest None Source code in pychamber/classes/network_model.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def mags ( self , freq : Optional [ str ] = None , azimuth : Optional [ float ] = None , elevation : Optional [ float ] = None , ) -> np . ndarray : \"\"\"Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: ```py import pychamber data = pychamber.load(\"/path/to/data\") # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data[\"Vertical\"] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert.mags(freq=\"2.45 GHz\", elevation=0) ``` This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Args: freq: Frequency of interest azimuth: Azimuth of interest elevation: Elevation of interest \"\"\" log . debug ( \"Fetching Mags\" ) if len ( self ) == 0 : return np . array ([]) else : params = dict () if azimuth is not None : params [ 'azimuth' ] = azimuth if elevation is not None : params [ 'elevation' ] = elevation log . debug ( f \" { params =} \" ) if freq : return np . array ([ n [ freq ] . s_db for n in self . sel ( params )]) . reshape ( - 1 , 1 ) # type: ignore else : return self . sel ( params )[ 0 ] . s_db . reshape ( - 1 , 1 ) # type: ignore","title":"Network model"},{"location":"reference/network_model/#pychamber.classes.network_model.NetworkModel","text":"Bases: NetworkSet Set of Networks that represent one meausurement. Extends scikit-rf's NetworkSet to provide helper functions relevant to chamber measurements. Attributes: Name Type Description freqs np . ndarray List of frequencies in the set azimuths np . ndarray List of azimuths in the set elevations np . ndarray List of elevations in the set Source code in pychamber/classes/network_model.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class NetworkModel ( NetworkSet ): \"\"\"Set of Networks that represent one meausurement. Extends scikit-rf's NetworkSet to provide helper functions relevant to chamber measurements. Attributes: freqs: List of frequencies in the set azimuths: List of azimuths in the set elevations: List of elevations in the set \"\"\" @property def freqs ( self ) -> np . ndarray : \"\"\"The list of frequencies contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return self [ 0 ] . frequency . f # type: ignore @property def azimuths ( self ) -> np . ndarray : \"\"\"The list of azimuths contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'azimuth' ] for n in self . sel ({ 'elevation' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) @property def elevations ( self ) -> np . ndarray : \"\"\"The list of elevations contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'elevation' ] for n in self . sel ({ 'azimuth' : 0 })] # type: ignore ) . reshape ( - 1 , 1 ) def __str__ ( self ) -> str : if len ( self ) == 0 : return \"Empty NetworkModel\" else : return ( f \"NetworkModel(Frequency: { self [ 0 ] . frequency } ,\" # type: ignore f \"Azimuths: { len ( self . azimuths ) } points,\" f \"Elevations: { len ( self . elevations ) } points)\" ) def mags ( self , freq : Optional [ str ] = None , azimuth : Optional [ float ] = None , elevation : Optional [ float ] = None , ) -> np . ndarray : \"\"\"Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: ```py import pychamber data = pychamber.load(\"/path/to/data\") # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data[\"Vertical\"] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert.mags(freq=\"2.45 GHz\", elevation=0) ``` This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Args: freq: Frequency of interest azimuth: Azimuth of interest elevation: Elevation of interest \"\"\" log . debug ( \"Fetching Mags\" ) if len ( self ) == 0 : return np . array ([]) else : params = dict () if azimuth is not None : params [ 'azimuth' ] = azimuth if elevation is not None : params [ 'elevation' ] = elevation log . debug ( f \" { params =} \" ) if freq : return np . array ([ n [ freq ] . s_db for n in self . sel ( params )]) . reshape ( - 1 , 1 ) # type: ignore else : return self . sel ( params )[ 0 ] . s_db . reshape ( - 1 , 1 ) # type: ignore def append ( self , ntwk : Network ) -> NetworkModel : log . debug ( \"Appending to network model\" ) ret = NetworkModel ( list ( self ) + [ ntwk ]) # type: ignore log . debug ( f \" { ret =} \" ) return ret","title":"NetworkModel"},{"location":"reference/network_model/#pychamber.classes.network_model.NetworkModel.azimuths","text":"The list of azimuths contained in the set. Source code in pychamber/classes/network_model.py 39 40 41 42 43 44 45 46 47 @property def azimuths ( self ) -> np . ndarray : \"\"\"The list of azimuths contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'azimuth' ] for n in self . sel ({ 'elevation' : 0 })] # type: ignore ) . reshape ( - 1 , 1 )","title":"azimuths()"},{"location":"reference/network_model/#pychamber.classes.network_model.NetworkModel.elevations","text":"The list of elevations contained in the set. Source code in pychamber/classes/network_model.py 49 50 51 52 53 54 55 56 57 @property def elevations ( self ) -> np . ndarray : \"\"\"The list of elevations contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return np . array ( [ n . params [ 'elevation' ] for n in self . sel ({ 'azimuth' : 0 })] # type: ignore ) . reshape ( - 1 , 1 )","title":"elevations()"},{"location":"reference/network_model/#pychamber.classes.network_model.NetworkModel.freqs","text":"The list of frequencies contained in the set. Source code in pychamber/classes/network_model.py 31 32 33 34 35 36 37 @property def freqs ( self ) -> np . ndarray : \"\"\"The list of frequencies contained in the set.\"\"\" if len ( self ) == 0 : return np . array ([]) else : return self [ 0 ] . frequency . f # type: ignore","title":"freqs()"},{"location":"reference/network_model/#pychamber.classes.network_model.NetworkModel.mags","text":"Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: import pychamber data = pychamber . load ( \"/path/to/data\" ) # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data [ \"Vertical\" ] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert . mags ( freq = \"2.45 GHz\" , elevation = 0 ) This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Parameters: Name Type Description Default freq Optional [ str ] Frequency of interest None azimuth Optional [ float ] Azimuth of interest None elevation Optional [ float ] Elevation of interest None Source code in pychamber/classes/network_model.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def mags ( self , freq : Optional [ str ] = None , azimuth : Optional [ float ] = None , elevation : Optional [ float ] = None , ) -> np . ndarray : \"\"\"Fetches data filtered by the arguments provided. Any argument not passed will be interpreted as requesting all values of that type. Example: ```py import pychamber data = pychamber.load(\"/path/to/data\") # data = {\"Vertical\": NetworkModel, \"Horizontal\": NetworkModel} vert = data[\"Vertical\"] # Retrieve the primary azimuth cut-plane (theta=90) for 2.45GHz cut = vert.mags(freq=\"2.45 GHz\", elevation=0) ``` This example makes clear that theta in the traditional sense is different from elevation. Elevation is dependent on the positioner, but for the D6050 for example, if boresight is taken as (0 azimuth, 0 elevation), then elevation is the angle of rotation of the secondary-axis. Args: freq: Frequency of interest azimuth: Azimuth of interest elevation: Elevation of interest \"\"\" log . debug ( \"Fetching Mags\" ) if len ( self ) == 0 : return np . array ([]) else : params = dict () if azimuth is not None : params [ 'azimuth' ] = azimuth if elevation is not None : params [ 'elevation' ] = elevation log . debug ( f \" { params =} \" ) if freq : return np . array ([ n [ freq ] . s_db for n in self . sel ( params )]) . reshape ( - 1 , 1 ) # type: ignore else : return self . sel ( params )[ 0 ] . s_db . reshape ( - 1 , 1 ) # type: ignore","title":"mags()"}]}